{
  "title": "07-HBase-0203-Hbase的java的api",
  "cells": [
    {
      "type": "markdown",
      "data": "## 1, 准备工作\n* 01， maven依赖\n```xml\n<!--具体版本视情况而定-->\n<dependency>\n    <groupId>org.apache.hbase</groupId>\n    <artifactId>hbase-server</artifactId>\n    <version>1.2.3</version>\n</dependency>\n```\n\n* 02，拷贝hbase中的hbase-site.xml配置文件到resource中\n```xml\n<configuration>\n\t<property>\n\t    <name>hbase.cluster.distributed</name>\n\t    <value>true</value>\n\t</property>\n\n\t<!--指定hbase数据在hdfs上的存放路径-->\n\t<property>\n\t    <name>hbase.rootdir</name>\n\t    <value>hdfs://master:8020/hbase</value>\n\t</property>\n\n\t<!-- 配置zk地址 -->\n\t<property>\n\t    <name>hbase.zookeeper.quorum</name>\n\t    <value>slave01:2181,slave02:2181,slave03:2181</value>\n\t</property>\n\t<!-- zk的本地目录 -->\n\t<property>\n\t    <name>hbase.zookeeper.property.dataDir</name>\n\t    <value>/data/zookeeper</value>\n\t</property>\n</configuration>\n```"
    },
    {
      "type": "markdown",
      "data": "## 2, 插入api，包括单条插入和批量插入等\n```java\npackage im.ivanl001.bigData.Hbase;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.hbase.HBaseConfiguration;\nimport org.apache.hadoop.hbase.TableName;\nimport org.apache.hadoop.hbase.client.*;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-11-10 14:58\n * #description : HBase的基本测试\n **/\npublic class A01_Hbase_API_Test {\n\n\n    //这个只是好奇，如果插入一亿条数据需要多久，不过没插入完成就关门了，所以就不再插入了\n    @Test\n    public void hbase_batch_listPut01() throws Exception{\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        Table table = connection.getTable(TableName.valueOf(\"ns1:t3\"));\n\n        DecimalFormat decimalFormat = new DecimalFormat();\n        decimalFormat.applyPattern(\"000000000\");\n\n        long current01 = System.currentTimeMillis();\n\n        List<Put> putList = new ArrayList<Put>();\n        for (int i=0;i<100000000;i++) {\n\n            String row = \"r\" + decimalFormat.format(i);\n            String family = \"f1\";\n            //qualaifier：中文是限定词的意思\n            String qualifier = \"name\";\n            String value = \"ivanl\" + decimalFormat.format(i);\n\n            Put put = new Put(row.getBytes());\n            put.addColumn(family.getBytes(), qualifier.getBytes(), value.getBytes());\n            putList.add(put);\n\n            if (i % 100000 == 0) {\n                table.put(putList);\n                putList.clear();\n            }\n        }\n\n        //这里重新put一下防止因为最后的一个万一不整除出问题\n        table.put(putList);\n\n        long current02 = System.currentTimeMillis();\n        System.out.println(\"costTime:\" + (current02-current01));\n        //这个只是好奇，如果插入一亿条数据需要多久，不过没插入完成就关门了，所以就不再插入了\n    }\n\n\n    @Test\n    public void hbase_batch_listPut() throws Exception{\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        Table table = connection.getTable(TableName.valueOf(\"ns1:t2\"));\n\n\n        DecimalFormat decimalFormat = new DecimalFormat();\n        decimalFormat.applyPattern(\"0000000\");\n\n        long current01 = System.currentTimeMillis();\n\n        List<Put> putList = new ArrayList<Put>();\n        for (int i=0;i<10;i++) {\n\n            String row = \"r\" + decimalFormat.format(i);\n            String family = \"f1\";\n            //qualaifier：中文是限定词的意思\n            String qualifier = \"age\";\n            String value = decimalFormat.format(i);\n\n\n            Put put = new Put(row.getBytes());\n            put.addColumn(family.getBytes(), qualifier.getBytes(), value.getBytes());\n            putList.add(put);\n\n            if (i % 5000 == 0) {\n                table.put(putList);\n                putList.clear();\n            }\n        }\n\n        //这里重新put一下防止因为最后的一个万一不整除出问题\n        table.put(putList);\n\n        long current02 = System.currentTimeMillis();\n        System.out.println(\"costTime:\" + (current02-current01));\n        //costTime:31 717, 31秒，半分钟，哇，瞅瞅！！！！\n\n    }\n\n\n    //如果用单条put方式插入大批量数据，效率是不高的\n    @Test\n    public void hbase_batch_insert() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        Table table = connection.getTable(TableName.valueOf(\"ns1:t1\"));\n\n        DecimalFormat decimalFormat = new DecimalFormat();\n        decimalFormat.applyPattern(\"0000000\");\n\n        long current01 = System.currentTimeMillis();\n\n        for (int i=0;i<1000000;i++) {\n            String row = \"r\" + decimalFormat.format(i);\n            String family = \"f1\";\n            //qualaifier：中文是限定词的意思\n            String qualifier = \"name\";\n            String value = \"ivanl\" + decimalFormat.format(i);\n\n            Put put = new Put(row.getBytes());\n            put.addColumn(family.getBytes(), qualifier.getBytes(), value.getBytes());\n\n            table.put(put);\n        }\n\n        long current02 = System.currentTimeMillis();\n        System.out.println(\"costTime:\" + (current02-current01));\n        //costTime:1449 474，大概是25分钟的样子，oh，myGod!\n    }\n\n    @Test\n    public void decimalFormat_test() throws Exception {\n        DecimalFormat decimalFormat = new DecimalFormat();\n        //#对于整数部分没有影响, 对于小数部分：如果位数大于小数#个数，有几个#就保留几位，保留规则是大于5进一，否则舍去\n        //decimalFormat.applyPattern(\"##.##\")\n        //如果#中间有其他符号，这是数字之间用来分割的符号，4,343,343,333.35\n        //decimalFormat.applyPattern(\"###,###.##\");\n        //0：整数位不足个数补0，小数位不足个数也补0，0043333.30\n        decimalFormat.applyPattern(\"0000000.00\");\n        System.out.println(decimalFormat.format(43333.3));\n    }\n    \n\n    @Test\n    public void hbase_get_test() throws Exception{\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        Table table = connection.getTable(TableName.valueOf(\"ns1:t1\"));\n        Get get = new Get(\"r2\".getBytes());\n\n        //get.addColumn(\"f1\".getBytes(), \"name\".getBytes());\n\n        Result result = table.get(get);\n        byte[] value = result.getValue(\"f1\".getBytes(), \"name\".getBytes());\n        System.out.printf(new String(value));\n    }\n\n\n    //写入测试\n    @Test\n    public void hbase_put_test() throws IOException {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        Table table = connection.getTable(TableName.valueOf(\"ns1:t1\"));\n        Put put = new Put(\"r2\".getBytes());\n\n        put.addColumn(\"f1\".getBytes(), \"name\".getBytes(), \"Ivan Bool\".getBytes());\n\n        table.put(put);\n    }\n\n}\n```"
    },
    {
      "type": "markdown",
      "data": "## 3, 管理表api，包括禁用，创建，删除， 以及扫描表等\n```java\npackage im.ivanl001.bigData.Hbase;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.hbase.*;\nimport org.apache.hadoop.hbase.client.*;\nimport org.junit.Test;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NavigableMap;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-11-12 10:48\n * #description : hbaseApi\n **/\npublic class A02_Hbase_API02_Test {\n\n    //获取所有列族的数据\n    @Test\n    public void hbase_scan03_test() throws Exception {\n        \n        Long start = System.currentTimeMillis();\n        \n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t1\");\n        Table table = connection.getTable(tableName);\n\n        //注意：这里一定要指定开始行或者结束行什么的， 要不然全局扫描很可能很悲剧\n        //这里的开始行和结束行是前开后闭区间\n        Scan scan = new Scan().withStartRow(\"r0000000\".getBytes()).withStopRow(\"r0010000\".getBytes());\n\n        //也就是一次next请求会缓存多少数据，数据大一点，可以减少网络请求, 默认是不缓存的\n        //scan.setCaching(1000);\n        System.out.println(scan.getCaching());\n\n\n        ResultScanner resultScanner = table.getScanner(scan);\n\n        Iterator<Result> results = resultScanner.iterator();\n        while (results.hasNext()) {\n            Result result = results.next();\n\n            /*byte[] value = result.getValue(\"f1\".getBytes(), \"name\".getBytes());\n            System.out.println(new String(value));*/\n            //因为我们这里想要获取所有列族的数据，所以不能像上面那样指定具体的某一列族了\n            NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n            for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n                byte[] familyKey = entry.getKey();\n                NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n\n                for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n\n                    byte[] columnKey = entry1.getKey();\n                    NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n\n                    //对于一个具体的列，可能还有不同的版本\n                    for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n\n                        Long versionKey = entry2.getKey();\n                        byte[] versionValue = entry2.getValue();\n\n                        System.out.println(\"列族：\"+ new String(familyKey) + \", 列：\" + new String(columnKey) + \",版本号：\" + versionKey + \",值是：\" + new String(versionValue));\n\n                    }\n                }\n            }\n        }\n        Long end = System.currentTimeMillis();\n\n        System.out.println(\"完结撒花～～～ , 耗时:\"  + (end-start));\n        //完结撒花～～～ , 耗时:27085\n        //完结撒花～～～ , 耗时:26752\n        //差别也不是很大，不知道为啥教程里差别那么大\n    }\n    \n\n    //这里要去获取所有的某一列族的数据, 主要看while里面的代码\n    @Test\n    public void hbase_scan02_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t1\");\n\n        Table table = connection.getTable(tableName);\n\n        //注意：这里一定要指定开始行或者结束行什么的， 要不然全局扫描很可能很悲剧\n        //这里的开始行和结束行是前开后闭区间\n        Scan scan = new Scan().withStartRow(\"r0000000\".getBytes()).withStopRow(\"r0000060\".getBytes());\n        ResultScanner resultScanner = table.getScanner(scan);\n\n        Iterator<Result> results = resultScanner.iterator();\n        while (results.hasNext()) {\n            Result result = results.next();\n\n\n            /*byte[] value = result.getValue(\"f1\".getBytes(), \"name\".getBytes());\n            System.out.println(new String(value));*/\n            //因为我们这里想要获取某一列族的所有数据，所以不能像上面那样指定具体的某一列族和某一列了\n            Map<byte[], byte[]> familyMap = result.getFamilyMap(\"f1\".getBytes());\n\n            for (Map.Entry<byte[], byte[]> entry : familyMap.entrySet()) {\n                byte[] key = entry.getKey();\n                byte[] value = entry.getValue();\n                System.out.println(new String(key));\n                System.out.println(new String(value));\n            }\n        }\n\n        System.out.println(\"finished\");\n    }\n    \n\n\n    //扫描获取某一列族中某一列的值\n    @Test\n    public void hbase_scan01_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t1\");\n\n        Table table = connection.getTable(tableName);\n\n        //注意：这里一定要指定开始行或者结束行什么的， 要不然全局扫描很可能很悲剧\n        //这里的开始行和结束行是前开后闭区间\n        Scan scan = new Scan().withStartRow(\"r0000000\".getBytes()).withStopRow(\"r0000060\".getBytes());\n        ResultScanner resultScanner = table.getScanner(scan);\n\n        Iterator<Result> results = resultScanner.iterator();\n        while (results.hasNext()) {\n            Result result = results.next();\n            byte[] value = result.getValue(\"f1\".getBytes(), \"name\".getBytes());\n            System.out.println(new String(value));\n        }\n    }\n\n\n    //删除一条记录是不需要管理员权限的， 跟之前类似， 创建一个delete即可\n    @Test\n    public void hbase_deleteRow_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        Admin admin = connection.getAdmin();\n        TableName tableName = TableName.valueOf(\"ns2:t1\");\n        Table table = connection.getTable(tableName);\n\n\n\n        //先添加数据\n        /*Put put = new Put(\"r01\".getBytes());\n        put.addColumn(\"f1\".getBytes(), \"name\".getBytes(), \"Ivan Bool\".getBytes());\n        table.put(put);*/\n\n\n        //再删除数据\n        Delete delete = new Delete(\"r01\".getBytes());\n        //这里不添加列的话默认删除当前一行， 如果添加，仅仅删除当前限制的列\n        delete.addColumn(\"f1\".getBytes(), \"name\".getBytes());\n        table.delete(delete);\n\n\n        //获取看一下结果是什么样子的\n        /*Get get = new Get(\"r01\".getBytes());\n        Result result = table.get(get);\n        System.out.println(result.value());*/\n        //null，说明已经删除成功\n\n    }\n    \n\n    @Test\n    public void hbase_dropTable_test() throws Exception{\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        Admin admin = connection.getAdmin();\n        admin.deleteTable(TableName.valueOf(\"ns2:t1\"));\n\n        List<TableDescriptor> tableDescriptors = admin.listTableDescriptors();\n        for (TableDescriptor tableDescriptor : tableDescriptors) {\n            System.out.println(tableDescriptor.getTableName());\n        }\n\n        System.out.println(\"over\");\n\n    }\n\n\n    @Test\n    public void hbase_disableTable_test() throws Exception {\n        Configuration conf = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(conf);\n\n        Admin admin = connection.getAdmin();\n\n        admin.disableTable(TableName.valueOf(\"ns2:t1\"));\n        System.out.println(\"over\");\n    }\n\n\n\n    @Test\n    public void habse_createTable_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        Admin admin = connection.getAdmin();\n        TableName tableName = TableName.valueOf(\"ns2:t1\");\n\n        //TableDescriptor tableDescriptor = TableDescriptorBuilder.newBuilder(tableName).build();\n\n        HTableDescriptor tableDescriptor = new HTableDescriptor(tableName);\n        HColumnDescriptor columnDescriptor = new HColumnDescriptor(\"f1\");\n        tableDescriptor.addFamily(columnDescriptor);\n\n        //这个是保留删除的cell，但是这个boolean值就是不是有点多余\n        //columnDescriptor.setKeepDeletedCells(KeepDeletedCells.TRUE);\n\n\n        admin.createTable(tableDescriptor);\n\n        List<TableDescriptor> tables = admin.listTableDescriptors();\n        for (TableDescriptor table : tables) {\n            System.out.println(table.getTableName());\n        }\n\n        System.out.println(\"finished\");\n    }\n\n    \n    @Test\n    public void hbase_createNamespace_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        Admin admin = connection.getAdmin();\n        NamespaceDescriptor namespaceDescriptor = NamespaceDescriptor.create(\"ns2\").build();\n        admin.createNamespace(namespaceDescriptor);\n\n        NamespaceDescriptor[] descriptors = admin.listNamespaceDescriptors();\n        for (NamespaceDescriptor descriptor : descriptors) {\n            System.out.println(descriptor.getName());\n        }\n    }\n}\n```"
    },
    {
      "type": "markdown",
      "data": "## 4, 其他\n```java\npackage im.ivanl001.bigData.Hbase;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.hbase.Cell;\nimport org.apache.hadoop.hbase.HBaseConfiguration;\nimport org.apache.hadoop.hbase.TableName;\nimport org.apache.hadoop.hbase.client.*;\nimport org.junit.Test;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-11-12 16:15\n * #description : 版本相关的\n **/\npublic class A04_Hbase_API03_Test {\n\n\n    //这里要去获取所有的某一列族的数据, 主要看while里面的代码\n    @Test\n    public void hbase_get_versions_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns2:t4\");\n        Table table = connection.getTable(tableName);\n\n        Get get = new Get(\"r0001\".getBytes());\n        get.addColumn(\"f1\".getBytes(), \"name\".getBytes());\n        //我们系统设置的版本是3，所以这里没必要设置版本号大于3，因为即使是大于3，也不可能查出来大于3条的结果出来的\n        get.readVersions(3);\n\n        Result result = table.get(get);\n\n        List<Cell> cells = result.getColumnCells(\"f1\".getBytes(), \"name\".getBytes());\n        for (Cell cell : cells) {\n\n            Long stamp = cell.getTimestamp();\n            cell.getValueLength();\n            cell.getValueOffset();\n\n            byte[] valueArr = cell.getValueArray();\n            int start = cell.getValueOffset();\n            int length = cell.getValueLength();\n\n            byte[] value = new byte[length];\n            System.arraycopy(valueArr, start, value, 0, length);\n\n            System.out.println(\"stamp:\" + stamp + \", value:\" + new String(value));\n        }\n\n        //scan是不能设置版本的，这里不能用scan，只能用get\n        //注意：这里一定要指定开始行或者结束行什么的， 要不然全局扫描很可能很悲剧\n        //这里的开始行和结束行是前开后闭区间\n        /*Scan scan = new Scan();\n        ResultScanner resultScanner = table.getScanner(scan);\n        Iterator<Result> results = resultScanner.iterator();\n        while (results.hasNext()) {\n            Result result = results.next();\n            *//*byte[] value = result.getValue(\"f1\".getBytes(), \"name\".getBytes());\n            System.out.println(new String(value));*//*\n            //因为我们这里想要获取某一列族的所有数据，所以不能像上面那样指定具体的某一列族和某一列了\n            Map<byte[], byte[]> familyMap = result.getFamilyMap(\"f1\".getBytes());\n\n            for (Map.Entry<byte[], byte[]> entry : familyMap.entrySet()) {\n                byte[] key = entry.getKey();\n                byte[] value = entry.getValue();\n                System.out.println(new String(key));\n                System.out.println(new String(value));\n            }\n        }*/\n\n        System.out.println(\"finished\");\n    }\n}\n```"
    },
    {
      "type": "markdown",
      "data": ""
    }
  ]
}