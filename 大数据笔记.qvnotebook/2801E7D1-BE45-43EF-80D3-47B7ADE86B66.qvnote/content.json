{
  "title": "13-Spark2.1-0806-oop-面向对象编程",
  "cells": [
    {
      "type": "markdown",
      "data": "## 1， OOP基础\n```python\n#\n# author      : ivanl001\n# creator     : 2018-12-06 16:54\n# description : \n# \n# 定义类\nclass Dog:\n\n    # 01, 定义构造函数, 如果有了下面的带参数的构造器，这里的构造器就不能再写了\n    def __init__(self):\n        print(\"A:定义构造函数\")\n\n    def __init__(self, name, age, num):\n        #下面这三个可以直接理解成定义成员变量\n        self.name = name\n        self.age = age\n        self.num = num\n        print(\"A:定义构造函数\")\n\n    def __del__(self):\n        print(\"这个是对象销毁方法，也即是析构函数\")\n\n    # 02, 定义属性变量, 这里和静态成员变量还是有一定差别的， 这里的可以被更改的哈\n    name = \"ivanl001\"\n\n    # 03, 定义方法\n    @staticmethod\n    def play():\n        print(\"C:定义并调用方法: dog is playing\")\n\n    @staticmethod\n    def add(a:int, b:int):\n        return a+b\n\n    def print_name(self):\n        print(\"打印成员变量：\" + self.name)\n\n\n# 创建对象(python和java的一个不同就是python可以直接在同一个文件中定义类后并创建\n# dog01 = Dog()\n\n# 因为后来的构造方法新增了变量，所以在构造dog的时候需要添加参数\ndog = Dog(\"ivanl002\", 10, 10120945)\n\nprint(\"B:打印静态成员变量name:\" + dog.name)\n\n# play是静态方法，可以直接对象调用，也可以类调用哈\ndog.play()\nDog.play()\n\n# 对象方法\ndog.print_name()\n# 注意：这里不是静态方法，所以不能直接用Dog类进行调用\n# Dog.printName()\n\n\nprint(\"---------------对象属性-----------------\")\n# 判断对象是否有某个变量， 也可以判断是否有某个方法的\nprint(hasattr(dog, \"name\"))\nprint(hasattr(dog, \"add\"))\n# 获取属性值\nprint(getattr(dog, \"name\"))\n# 更改属性值\nsetattr(dog, \"name\", \"ivanl003\")\nprint(getattr(dog, \"name\"))\n# 删除属性值\ndelattr(dog, \"age\")\nprint(hasattr(dog, \"age\"))\n\n\n# 类属性\nprint(\"----------------类属性-----------------\")\ndogDict = Dog.__dict__\nfor key in dogDict.keys():\n    print(\"key:\" + key + \", value:\" + str(dogDict[key]))\n```"
    },
    {
      "type": "markdown",
      "data": "## 2, 多重继承\n```python\n#\n# author      : ivanl001\n# creator     : 2018-12-08 11:45\n# description : 多重继承\n# \nclass Horse:\n\n    name = \"\"\n\n    # 这种是私有属性，子类是不能继承的\n    __house_tailLength = 10\n\n    def __init__(self):\n        print(\"这是马--初始化\")\n\n    @staticmethod\n    def run():\n        print(\"马在跑----\")\n\n    # 如下：带有下划线的是私有方法\n    @staticmethod\n    def __house_do():\n        print(\"这个是马私有的方法，只有本类可以使用，子类也不能用\")\n\n    # 如果有self做参数，并且方法内部中使用到self相关的属性，就是对象方法\n    def house_work(self):\n        print(self.name)\n        print(\"这个是对象方法，因为有对象相关的属性：name:\" + self.name)\n\nclass Donkey:\n\n    def __init__(self):\n        print(\"这是驴--初始化\")\n\n    @staticmethod\n    def carry():\n        print(\"驴子在驼东西----\")\n\n# 可以看到骡子可以同时继承马和驴\nclass Luozi(Horse, Donkey):\n\n    def __init__(self):\n        # 如果想要调用父类方法\n        Donkey.__init__(self)\n        Horse.__init__(self)\n        print(\"这是骡子--初始化\")\n\n    @staticmethod\n    def scream():\n        print(\"骡子在叫----\")\n\n    # 重写父类方法\n    @staticmethod\n    def run():\n        Horse.run()\n        print(\"重写父类的方法，先实现父类调用，在调用自身， 骡子也要跑---\")\n\n    # 这里如果重写父类方法而不调用父类， 那么就相当与是覆盖了父类方法\n    def house_work(self):\n        print(\"lll\" + self.name)\n\nluozi = Luozi()\nluozi.name = \"ivanl001\"\n\nluozi.run()\nluozi.carry()\nluozi.scream()\nluozi.house_work()\n```"
    }
  ]
}