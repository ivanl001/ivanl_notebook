{
  "title": "12-Scala-0113-OOP",
  "cells": [
    {
      "type": "markdown",
      "data": "### 第五章: Object Oriented Programming\n\n### 第五章 类（比较抽象，略过）\n### 第六章 对象（比较抽象，略过）\n### 第七章 包和引入（比较抽象，略过）\n### 第八章 继承（比较抽象，略过）"
    },
    {
      "type": "markdown",
      "data": "*看书和代码吧，没啥好写的，索性把教程中第一天的所有笔记拷贝一份记录一下*"
    },
    {
      "type": "markdown",
      "data": "```scala\nscala\n-------------\n\tjava语言的脚本化。\n \nREPL\n-----------------\n\tread + evaluate + print + loop\n\n安装scala解释程序\n------------------\n\t1.scala-2.12.1.msi\n\t2.进入scala命令行\n\n\t\t//变量\n\t\tscala>var a = 100\t\t\t//变量\n\n\t\t//常量\n\t\tscala>val a = 100\t\t\t//常量，不能重新赋值。\n\n\t\t//定义类型\n\t\tscala>val a:String = \"hello\" ;\n\t\tscala>a = \"world\"\t\t\t//wrong\n\n\n\t//操作符重载 _ $\n\tscala>1 + 2\n\tscala>1.+(2)\t\t\t\t\t//\n\n\n\t//scala函数,没有对象.\n\t//scala方法，通过对象调用。\n\tscala>import scala.math._\t\t//_ ===> *\n\tscala>min(1,2)\n\n\t//\n\tscala>1.toString\t\t\t\t//方法\n\tscala>1.toString()\t\t\t\t//方法形式\n\tscala>1 toString\t\t\t\t//运算符方式\n\n\t//apply\n\tscala>\"hello\".apply(1)\t\t\t//等价于xxx.apply()\n\tscala>\"hello\"(1)\t\t\t\t//\n\n\t//条件表达式,scala的表达式有值,是最后一条语句的值。\n\tscala>val x = 1 ;\n\tscala>val b = if x > 0 1 else -1 ;\n\n\t//Any 是Int和String的超类。\n\n\t//类型转换\n\tscala>1.toString()\n\tscala>\"100\".toInt()\t\t\t\t//\n\n\t//空值\n\tscala>val y = (x = 1)\t\t\t//y:Unit= ()类似于java void.\n\t\t\n\t\n\t//粘贴复制\n\tscala>:paste\n\t\t\t....\n\t\tctrl + d\t\t\t\t\t//结束粘贴模式\n\n        javac               java\n\t\t*.java --------> *.class  -------->程序 \n\n\n\t//输出\n\tscala>print(\"hello\")\n\tscala>println(\"hello\")\n\tscala>printf(\"name is %s , age is %d\", \"tom\",12);\n\t//读行\n\tscala>val password = readLine(\"请输入密码 : \") ;\n\n\t//查看帮助\n\tscala>:help\n\t\n\n\t\n\t//循环\n\tscala>:paste\n\t\tvar i = 0 ;\n\t\twhile(i < 10 ){\n\t\t\tprintln(i) ;\n\t\t\ti += 1;\n\t\t}\n\n\t//99表格\n\tscala>:paste\n\t\tvar row = 1 ; \n\t\twhile(row <= 9 ){\n\t\t\tvar col = 1 ; \n\t\t\twhile(col <= row){\n\t\t\t\tprintf(\"%d x %d = %d\\t\",col,row,(row * col)) ;\n\t\t\t\tcol += 1 ;\n\t\t\t}\n\t\t\tprintln();\n\t\t\trow += 1 ;\n\t\t}\n\t\n\t//百钱买白鸡问题.\n\t\t100块钱100只鸡。\n\t\t公鸡:5块/只\n\t\t母鸡:3块/只\n\t\t小鸡:1块/3只\n\t\n\t//公鸡\n\tvar cock = 0 ;\n\twhile(cock <= 20){\n\t\t//母鸡\n\t\tvar hen = 0 ;\n\t\twhile(hen <= 100/3){\n\t\t\tvar chicken = 0 ;\n\t\t\twhile(chicken <= 100){\n\t\t\t\tvar money = cock * 5 + hen * 3 + chicken / 3 ;\n\t\t\t\tvar mount = cock + hen + chicken ;\n\t\t\t\tif(money == 100 && mount == 100){\n\t\t\t\t\tprintln(\"cock : %d , hen : %d , chicken : %d\",cock,hen,chicken) ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//for循环\n\t//to []\n\tscala>for (x <- 1 to 10){\n\t\tprintln(x) ;\n\t}\n\n\t//until [1,...10)\n\tscala>for (x <- 1 10){\n\t\tprintln(x) ;\n\t}\n\n\t//scala没有break continue语句。可以使用Breaks对象的break()方法。\n\tscala>import scala.util.control.Breaks._\n\tscala>for(x <- 1 to ) {break() ; print(x)} ;\n\n\n\t//for循环高级\n\t//双循环,守卫条件\n\tscala>for(i <- 1 to 3 ; j <- 1 to 4 if i != j ) {printf(\"i = %d, j = %d , res = %d \",i,j,i*j);println()} ;\t\n\t\n\t//yield，是循环中处理每个元素，产生新集合\n\tscala>for (x <- 1 to 10 ) yield x % 2 ; \n\n\n\t//定义函数\n\tdef add(a:Int,b:Int):Int = {\n\tvar c = a + b  ;\n\treturn c  ;\n\t}\n\n\tscala>def add(a:Int,b:Int):Int =\ta + b \n\n\t//scala实现递归 n! = n * (n - 1)!\n\t4!  = 4 x 3!\n\t4!  = 4 x 3 x 2!\n\t4!  = 4 x 3 x 2 x 1!\n\t\n\t//递归函数必须显式定义返回类型\n\tscala>def fac(n:Int):Int = if(n ==1 ) 1 else n * fac(n-1) ;\n\n\n\t//函数的默认值和命名参数\n\tscala>def decorate(prefix:String = \"[[\",str:String,suffix:String = \"]]\") = {\n\t\tprefix + str + suffix \n\t}\n\n\tscala>decorate(str=\"hello\")\n\tscala>decorate(str=\"hello\",prefix=\"<<\")\n\n\t//变长参数\n\tscala>def sum(a:Int*) = {\n\t\tvar s = 0 ;\n\t\tfor (x <- a) s += x;\n\t\ts\n\t\t}\n\n\tscala>add(1 to 10)\t\t\t//wrong\n\tscala>add(1 to 10:_*)\t\t//将1 to 10当做序列处理。\n\tscala>def sum(args:Int*):Int = {if (args.length == 0) 0 else args.head + sum(args.tail:_*)}\n\n\t//过程,没有返回值，没有=号。\n\tscala>def out(a:Int){\n\t\tprintln(a) ;\n\t}\n\n\t//lazy延迟计算\n\tscala>lazy val x = scala.io.Source.fromFile(\"d:/scala/buy.scala00\").mkString()\n\t\t\tx:<lazy>\n\t\t\tx\n\n\t//异常\n\tscala>\n\t\ttry{\n\t\t  \"hello\".toInt;\n\t\t}\n\t\tcatch{\t\t\t\t\t//交给\n\t\t\tcase _:Exception    => print(\"xxxx\") ;\n\t\t\tcase ex:java.io.IOException => print(ex)\n\t\t}\n\n\n_的意义\n---------------------\n\t1.统配相当于*\n\t2.1 to 10 :_*\t,转成序列\n\t3.case _:Exception    => print(\"xxxx\") ;\n\n数组(定长)\n---------------\n\tjava : int[] arr = int int[4] ;\n\tscala>var arr = new Array[Int](10);\t\t\t//apply(10)\n\tscala>var arr = Array(1,2,3,4,);\t\t\t//推断\n\tscala>arr(0)\t\t\t\t\t\t\t\t//按照下标访问元素\n\n变长数组\n-------------------\n\tscala>import scala.collection.mutable.ArrayBuffer\n\tscala>val buf = ArrayBuffer[Int]();\t\t\t//创建数组缓冲区对象\n\n\t//+=在末尾追加\n\tscala>buf += 1\n\n\t//操纵集合\n\tscala>buf ++= ...\n\n\t//trimEnd,从末尾移除元素\n\tscala>buf.trimStart(2)\n\tscala>buf.trimEnd(2)\n\n\t//insert,在0元素位置插入后续数据\n\tscala>buf.insert(0,1,2)\n\t\n\t//remove按照索引移除\n\tscala>buf.remove(0)\n\n\t//toArray\n\tscala>buf.toArray\n\n\t//数组操作\n\tscala>for (x <- 1 to 10 if x % 2 ==0) yield x * 2\t//\n\tscala>var a = Array(1 to 10)\n\n\t//数组常用方法\n\tscala>arr.sum\n\tscala>arr.min\n\tscala>arr.max\n\n\t\n\t//排序\n\tscala>import scala.util.Sorting._\n\tscala>val arr = Array(1,4,3,2)\n\tscala>quickSort(arr)\t\t\t\t//arr有序\n\n\t//Array.mkString\n\tscala>arr.mkString(\"<<\",\",\",\">>\")\t//<<1,2,3,4>>\n\n\t//多维数组\n\tscala>var arr:Array[Int] =new Array[Int](4);\n\t//二维数组,3行4列\n\tscala>val arr = Array.ofDim[Int](3,4)\n\t//下标访问数组元素\n\tscala>arr(0)(1)\n\tscala>arr.length\n\n\n\t//和java对象交互，导入转换类型,使用的隐式转换\n\tscala>import scala.collection.JavaConversions.bufferAsJavaList\n\tscala>val buf = ArrayBuffer(1,2,3,4);\n\tscala>val list:java.util.List[Int] = buf ;\n\n\n\t//映射和元组\n\t//key->value\n\t//scala.collection.immutable.Map[Int,String] =不可变集合\n\tscala>val map = Map(100->\"tom\",200->\"tomas\",300->\"tomasLee\")\n\t//通过key访问value\n\tscala>map(100)\n\tscala>val newmap = map + (4->\"ttt\")\n\t\n\t//可变\n\tscala>val map = new scala.collection.mutable.HashMap[Int,Int]\n\tscala>val map = scala.collection.mutable.HashMap[Int,Int]()\n\tscala>map += (1->100,2->200)\t//追加\n\tscala>map -= 8\t\t\t\t\t//移除元素\n\n\t//迭代map\n\tscala>for ((k,v)<- map) println(k + \":::\" + v);\n\n\t//使用yield操作进行倒排序(kv对调),\n\tscala>for ((k,v)<- map) yield (v,k);\n\n\t//元组tuple,元数最多22-->Tuple22\n\tscala>val t = (1,\"tom\",12) ;\n\n\t//访问元组指定元\n\tscala>t._2\n\tscala>t _2\n\t//直接取出元组中的各分量\n\tscala>val (a,b,c) = t\t\t//a=1,b=\"tom\",c=12\n\t\n\t//数组的zip,\n\t//西门庆 -> 潘金莲  牛郎 -> 侄女  ,\n\tscala>val hus = Array(1,2,3);\n\tscala>val wife = Array(4,5,6);\n\tscala>hus.zip(wife)\t\t//(1,4),(2,5),(3,6)\n\n\nOOP\n----------------\n\tscala>class Person{\n\t\t//定义变量,私有类型,必须初始化\n\t\t//set/get也私有\n\t\tprivate var id = 0 ;\n\t\t\n\t\t//只有get方法，没有set方法\n\t\tval age = 100 ;\n\n\t\t//生成私有属性，和共有的get/set方法。\n\t\tvar name = \"tom\" ;\n\t\t//默认public\n\t\tdef incre(a:Int) = {id += a ;}\n\t\t//如果定义时，没有(),调用就不能加()\n\t\tdef current() = id \n\t}\n\n\tscala>var p = new Person();\n\tscala>p.current()\n\tscala>p.current\n\tscala>p.incr(100)\n\tscala>p.name\n\tscala>p.name_=(\"kkkk\")\n\tscala>p.name = \"kkkk\"\n\n\nprivate[this]作用,控制成员只能在自己的对象中访问。\n-------------------\n\tclass Counter{\n\t\tprivate[this] var value =  0 ;\n\t\tdef incre(n:Int){value += n}\n\n\t\tdef isLess(other:Counter) = value < other.value ;\n\t}\n\n定义BeanProperty注解\n----------------------\n\tclass Person{\n\t\t@scala.reflect.BeanProperty\n\t\tvar  name:String  = _\n\t}\n\n\n构造函数\n----------------\n\t主构造器\t\t//\n\t辅助构造\t\t//\n\t\n\tclass Person{\n\t\tvar id = 1 ;\n\t\tvar name = \"tom\" ;\n\t\tvar age = 12;\n\n\t\t//辅助构造\n\t\tdef this(name:String){\n\t\t\tthis();\n\t\t\tthis.name = name ;\n\t\t}\n\t\t//辅助构造\n\t\tdef this(name:String,age:Int){\n\t\t\t//调用辅助构造\n\t\t\tthis(name) ;\n\t\t\tthis.age = age ;\n\t\t}\n\t}\n\n\t\n\t//主构造\n\t//val ===> 只读\n\t//var ==> get/set\n\t//none ==> none\n\tclass Person(val name:String,var age:Int , id :Int){\n\t\t\n\t\tdef hello() = println(id)\n\t}\n\n\nObject\n-----------------\n\t说明：scala没有静态的概念，如果需要定义静态成员，可以通过object实现。\n\t      编译完成后，会生成对应的类，方法都是静态方法，非静态成员对应到单例类中\n\t\t  单例类以Util$作为类名称。\n\n\tscala>object Util{\n\t\t//单例类中.(Util$)\n\t\tprivate var brand = \"benz\" ;\n\t\t//静态方法.\n\t\tdef hello() = println(\"hello world\");\n\t}\n\n伴生对象(companions object)\n--------------------------\n\t类名和object名称相同，而且必须在一个scala文件中定义。\n\tclass Car{\n\t\tdef stop() = println(\"stop....\")\n\t}\n\n\tobject Car{\n\t\tdef run() = println(\"run...\")\n\t}\n\n抽象类\n--------------\n\t//定义抽象类\n\tabstract class Dog{\n\t\tdef a():Unit\n\t}\n\n\nobject等价于java中的静态。\n---------------------------\n\tobject Jing8 extends Dog{\n\t\t//重写方法\n\t\toverride def a():Unit= print(\"hello\") ;\n\t}\n\nobject Util{\n\tdef apply(s:String) = println(s) ;\n}\n\nUtil(\"hello world\");\nUtil.apply(\"hello world\");\n\ntrait\n----------\n\t特质，等价于java中的接口.\n\n\nscalac编译scala文件，产生class文件。\n------------------------------------\n\tcmd>scalac xxxx.scala\n\n运行class程序\n--------------------\n\tcmd>scala Person\n\n一步到位\n-------------------\n\tcmd>scala Person.scala\n\nidea中安装scala插件\n------------------------\n\n\n\ntrait\n-----------\n\ttraint HelloService{\n\t}\n\n\n//包对象，编译完之后生成以xxx为package，下面含有类package.class + package.class\npackage object xxxx{\n\n}\n\n\n//约束可见性。\n-----------------------\nprivate[package|this]\n\n导入\n--------------\nimport java.io.Exception\nimport java.io.{A,B,C}\t\t\t//\nimport java.io.{A => A0}\t\t//别名\n\n\n```"
    },
    {
      "type": "markdown",
      "data": ""
    }
  ]
}