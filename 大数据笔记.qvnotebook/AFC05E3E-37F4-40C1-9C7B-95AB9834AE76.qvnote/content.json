{
  "title": "06-Zookeeper-0101-zk的安装和基本使用",
  "cells": [
    {
      "type": "markdown",
      "data": "## 1, zk的安装\n* 01，下载zookeeper-3.4.9.tar.gz\n* 02，解压，放在/usr/local/目录下\n* 03, 更改配置文件，复制zoo_sample.cfg到一个新文件zoo.cfg中，并更改数据保存目录：\n  ```\n  dataDir=/tmp/zookeeper\n  ```\n* 04, 在/usr/local下创建软链接zookeeper，指向刚才解压后到文件夹\n\n* 05, 配置/etc/profile文件\n  ```shell\n  export ZK_HOME=/usr/local/zookeeper\n  export PATH=$PATH:$ZK_HOME/bin\n  ```\n* 06, 重新加载profile文件\n  > source /etc/profile;\n\n* 07, 正常启动zk应该可以, 启动后应该可以查看到有一个2181端口正在被监听\n  > zkServer.sh start\n\n* 08, 启动后可以查看zk的状态\n  > zkServer.sh status\n\n* 08, 启动后就可以进行远程连接，连接方式大致如下：\n  > zkCli.sh -server slave01:2181"
    },
    {
      "type": "markdown",
      "data": "## 2, zk的基本使用\n*每一个目录都是一个节点*\n\n* 01，显示节点目录文件\n  > ls /\n  > ls /zookeeper\n  > ls /zookeeper/quota\n\n* 02，创建节点\n  > create /ivanl001 ivanl001\n  > create /ivanl001/ivanl002 ivanl002\n\n* 03, 获取节点的信息和值\n  > get /ivanl001\n\n* 04, 更改某个节点的值\n  > set /ivanl001/ivanl002 ivanl00200\n\n* 05, 删除某个节点\n  > delete /a\n\n* 06, 如果/a下面有其他的内容，delete删不掉的，需要递归删除\n  > rmr /a"
    },
    {
      "type": "markdown",
      "data": "## 3, 代码连接zk处理\n*比较简单，直接上代码*\n\n```java\npackage im.ivanl001.bigData.Zookeeper;\n\nimport org.apache.zookeeper.KeeperException;\nimport org.apache.zookeeper.ZooKeeper;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-11-07 12:24\n * #description : zk的简单测试\n **/\npublic class A01_Zookeeper {\n\n    private static ZooKeeper zk;\n    static {\n        try {\n            zk = new ZooKeeper(\"slave01:2181\", 5000, null);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    @Test\n    public void zk_lsAll_test() throws Exception {\n        ls_all(\"/\");\n    }\n\n    //迭代输出所有的路径\n    public void ls_all(String path) throws Exception{\n        List<String> results = zk.getChildren(path, null);\n        if (results.isEmpty() || results == null) {\n            return;\n        }else {\n            for (String str : results) {\n                //System.out.println(str);\n\n                if (\"/\".equals(path)) {\n                    System.out.println(path + str);\n                    //这里需要注意的是：如果是最上一级，其实就是一个 \"/\", 需要特殊处理\n                    //System.out.println(\"---\" + path  + str);\n                    ls_all(path + str);\n                }else {\n                    System.out.println(path + \"/\" + str);\n                    //System.out.println(\"---\" + path + \"/\" + str);\n                    ls_all(path + \"/\" + str);\n                }\n\n            }\n        }\n    }\n\n    @Test\n    public void zk_ls_test() throws IOException, KeeperException, InterruptedException, Exception {\n\n        ZooKeeper zk = new ZooKeeper(\"slave01:2181\", 5000, null);\n        List<String> results = zk.getChildren(\"/\", null);\n\n        for (String str : results) {\n            System.out.println(str);\n        }\n    }\n}\n\n```"
    },
    {
      "type": "markdown",
      "data": "## 4, zk架构\n```java\nzk架构\n------------------\n\t1.Client\n\t\t从server获取信息，周期性发送数据给server，表示自己还活着。\n\t\tclient连接时，server回传ack信息。\n\t\t如果client没有收到reponse，自动重定向到另一个server.\n\n\t2.Server\n\t\tzk集群中的一员，向client提供所有service，回传ack信息给client，表示自己还活着。\n\n\t3.ensemble\n\t\t一组服务器。\n\t\t最小节点数是3.\n\n\t4.Leader\n\t\t如果连接的节点失败，自定恢复，zk服务启动时，完成leader选举。\n\n\t5.Follower\n\t\t追寻leader指令的节点。\n\t\t\nznode\n------------------\n\tzk中的节点，维护了stat，由Version number, Action control list (ACL), Timestamp,Data length.构成.\n\tdata version\t\t//数据写入的过程变化\n\n\tACL\t\t\t\t\t//action control list,\n\t\n节点类型\n-----------------\n\t1.持久节点\n\t\tclient结束，还存在。\n\t\t\n\t2.临时节点\n\t\t在client活动时有效，断开自动删除。临时节点不能有子节点。\n\t\tleader推选是使用。\n\t\t大概意思是leader推选的时候创建临时节点，如果这个Leader不幸dead了, 那么这个节点也就会被删除，其他服务器能监听到这个节点的删除，就能重新推选新的leader了。推选的规则在后面再介绍\n\n\t3.序列节点\n\t\t在节点名之后附加10个数字，主要用于同步和锁.\n\t\t\n\t\t\nSession\n--------------------\n\tSession中的请求以FIFO执行，一旦client连接到server，session就建立了。sessionid分配client.\n\n\tclient以固定间隔向server发送心跳，表示session是valid的，zk集群如果在超时时候，没有收到心跳，\n\t判定为client挂了，与此同时，临时节点被删除。\n\nWatches\n-------------------\n\t观察。\n\tclient能够通过watch机制在数据发生变化时收到通知。\n\tclient可以在read 节点时设置观察者。watch机制会发送通知给注册的客户端。\n\t观察模式只触发一次。\n\tsession过期，watch机制删除了。\n\n\nzk工作流程\n----------------\n\tzk集群启动后，client连接到其中的一个节点，这个节点可以leader，也可以follower。\n\t连通后，node分配一个id给client，发送ack信息给client。\n\t如果客户端没有收到ack，连接到另一个节点。\n\tclient周期性发送心跳信息给节点保证连接不会丢失。\n\n\t如果client读取数据，发送请求给node，node读取自己数据库，返回节点数据给client.\n\n\n\t如果client存储数据，将路径和数据发送给server，server转发给leader。\n\tleader再补发请求给所有follower。只有大多数(超过半数)节点成功响应，则\n\t写操作成功。\n\n```"
    }
  ]
}