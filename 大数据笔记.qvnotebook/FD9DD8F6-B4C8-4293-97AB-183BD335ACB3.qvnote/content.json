{
  "title": "01-Java基础-0300-Socket",
  "cells": [
    {
      "type": "markdown",
      "data": "> Socket = IP + TCP/UDP + port\n> socket就是套接字，套接字到作用就是建立通信"
    },
    {
      "type": "markdown",
      "data": "## 1，OSI七层网络模型(Open System Interconnect)\n1. 物理层\n2. 链路层\n3. 传输层\n    * TCP协议，面向连接到协议\n    * UDP协议，无连接协议\n4. 网络层\n    * ip协议\n5. 会话层\n6. 表示层\n7. 应用层\n    * http，https协议\n    * ftp：file transfer prot\n\n![IMAGE](quiver-image-url/1AFC5EC106629F0593C0830F45088C71.jpg =902x579)\n![IMAGE](quiver-image-url/A31BE366412D8CD6CE23C7E9B8A4BD7E.jpg =914x594)"
    },
    {
      "type": "markdown",
      "data": "## 2，UDP案例\n*DatagramSocket: udp套接字*\n* 不保证消息会被收到\n* 没有固定路由，先发送的消息可能会后收到\n* 所以也就没有服务器的概念，只有发送方和接收方的概念\n* 发送的包叫做DatagramPack：内部需要指定接收方的ip+port\n"
    },
    {
      "type": "markdown",
      "data": "## 3, TCP协议三次握手机制\n1. A发送sync信号(序号是x)给B，B接受这个同步信号\n2. B接受后再给A发送sync信号(序号是y,确认号x+1), A接受这个同步信号\n3. A再给B发送ACK信号(序号是y+1)，B接受到之后正式建立连接，开始通信"
    },
    {
      "type": "markdown",
      "data": "## 4，UDP的屏幕广播案例"
    },
    {
      "type": "markdown",
      "data": "### 4.1, Capturer\n`屏幕录屏的服务端,通过robot录屏，然后根据协议是：8位时间戳 + 1位分片数 + 1位编号 + 4位的数据长度 + 数据长度的数据进行转换成字节流通过UDP发送出去`"
    },
    {
      "type": "markdown",
      "data": "```java\npackage im.ivanl001.bigData.java_01.Java.IM001_ScreenBroadcast;\n\nimport javax.swing.*;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-10-14 10:53\n * #description :\n **/\npublic class App extends JFrame{\n\n    private JLabel lblIcon ;\n\n    public App(){\n        init();\n    }\n\n    private void init() {\n        this.setTitle(\"屏幕分享\");\n        this.setBounds(0, 0, 1366, 768);\n        this.setLayout(null);\n\n        lblIcon = new JLabel();\n        lblIcon.setBounds(0, 0, 1366, 768);\n\n        ImageIcon icon = new ImageIcon(\"D:/Koala.jpg\");\n        lblIcon.setIcon(icon);\n        this.add(lblIcon);\n        this.setVisible(true);\n    }\n\n    public void updateIcon(byte[] dataBytes){\n        ImageIcon icon = new ImageIcon(dataBytes);\n        lblIcon.setIcon(icon);\n    }\n\n}\n```"
    },
    {
      "type": "markdown",
      "data": "### 4.2, Receiver\n`真正的客户端程序，通过调用UI类，并从接受类获取数据`"
    },
    {
      "type": "markdown",
      "data": "```java\npackage im.ivanl001.bigData.java_01.Java.IM001_ScreenBroadcast;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-10-13 20:46\n * #description : 接收方\n **/\npublic class Receiver {\n\n    public static void main(String[] args) {\n\n        App app = new App();\n\n        IMReceive imReceive = new IMReceive(app);\n        imReceive.start();\n    }\n}\n```"
    },
    {
      "type": "markdown",
      "data": "### 4.2，客户端的ui界面\n`用来显示界面的`"
    },
    {
      "type": "markdown",
      "data": "```java\npackage im.ivanl001.bigData.java_01.Java.IM001_ScreenBroadcast;\n\nimport im.ivanl001.bigData.java_01.IMUtils.IMByteArr0NumUtils;\nimport im.ivanl001.bigData.java_01.IMUtils.IMCaptureUtils;\nimport im.ivanl001.bigData.java_01.IMUtils.IMUDPUtils;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-10-13 19:05\n * #description : 截屏方\n **/\npublic class Capturer {\n\n    public static void main(String[] args) {\n\n        int i = 0;\n        //循环的截图并发送\n        while (true) {\n            i += 1;\n            captureOneAndSend();\n            System.out.println(\"--------------------------发送图片：\" + i);\n            //break;//循环暂且关掉\n        }\n    }\n\n    public static void captureOneAndSend() {\n\n        int maxSize = 60 * 1024;\n\n        //首先截屏，然后转换成字节数组，这个过程应该一直操作,开始的时候先用静态\n        byte[] picBytes = IMCaptureUtils.captureAndGetByteArr();\n        //记录时间戳，作为本帧图片的标记\n        Long currentTimeStamp = System.currentTimeMillis();\n\n        //然后处理图片，如果图片大于60K，把图片进行切分处理\n        int dataLen = picBytes.length;\n        int count = 0;\n        int lastSliceLen = 0;//最后一个切片的长度\n\n        // 如果能整除，ok，那刚刚好\n        if (dataLen % (maxSize) == 0) {\n            count = dataLen/(maxSize);\n            lastSliceLen = maxSize;\n        }else{\n            count = (dataLen/(maxSize))+1;\n            lastSliceLen = dataLen % (maxSize);\n        }\n\n        //这个是每个切片的长度\n//        int sliceLen =\n\n\n        for (int i=0;i<count;i++) {\n\n            //在这里把数组组装起来，发送\n            byte[] sliceData = null;\n            int sliceLen = 0;\n            if (i == count - 1) {\n                sliceData = new byte[lastSliceLen];\n                sliceLen = lastSliceLen;\n            }else {\n                sliceData = new byte[maxSize];\n                sliceLen = maxSize;\n            }\n\n            //计算中长度：协议是：8位时间戳 + 1位分片数 + 1位编号 + 4位的数据长度 + 数据长度的数据\n            int totalLen = 8 + 1 + 1 + 4 + sliceLen;\n\n            //初始化字节数组，然后把所有需要的信息都写入内，方便后续进行udp发送\n            byte[] frameUnitBytes = new byte[totalLen];\n\n            //1，处理时间戳，这个时间戳是截图的时间戳，这样子的话每个frameunit的时间戳才会相同\n            byte[] timeBytes = IMByteArr0NumUtils.long2byteArr(currentTimeStamp);\n            System.arraycopy(timeBytes, 0, frameUnitBytes, 0, 8);\n\n            //2,总分片数,因为切片个数不大可能大于一个字节8位，所以直接转成byte类型即可\n            byte countBytes = (byte)count;\n            //System.arraycopy(countBytes, 0, frameUnitBytes, 8, 1);\n            //直接赋值吗\n            frameUnitBytes[8] = countBytes;\n\n            //3,序号\n            byte no = (byte)i;\n            //System.arraycopy(no, 0, frameUnitBytes, 9, 1);\n            frameUnitBytes[9] = no;\n\n            //4,这个是切片的长度，不是整个图片的长度哈\n            byte[] length = IMByteArr0NumUtils.int2byteArr(sliceLen);\n            System.arraycopy(length, 0, frameUnitBytes, 10, 4);\n\n            //5, 数据\n            //picBytes;;\n\n            System.arraycopy(picBytes, i*60*1024, sliceData, 0, sliceLen);\n\n            System.out.println(picBytes.length + \"-------\");\n\n            //System.arraycopy(picBytes, 0, frameUnitBytes, 14, dataLen);\n\n            System.arraycopy(picBytes, i*maxSize, frameUnitBytes, 14, sliceLen);\n\n            System.out.println(frameUnitBytes.length);\n\n            // 发送之前把字节数组压缩以下\n            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n            ZipOutputStream zipOutputStream = new ZipOutputStream(byteArrayOutputStream);\n            try {\n                zipOutputStream.putNextEntry(new ZipEntry(\"frameUnitZip\"));\n                zipOutputStream.write(frameUnitBytes);\n\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    zipOutputStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                } finally {\n                    try {\n                        byteArrayOutputStream.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n            byteArrayOutputStream.toByteArray();\n\n            //发送\n            IMUDPUtils.UdpSendBytes(byteArrayOutputStream.toByteArray());\n\n            System.out.println(\"发送切片：\" + i);\n\n        }\n    }\n}\n\n```"
    },
    {
      "type": "markdown",
      "data": "### 4.4， IMReceive\n`真正用来接受数据的类，通过发送的数据的协议进行反解出来`"
    },
    {
      "type": "markdown",
      "data": "```java\npackage im.ivanl001.bigData.java_01.Java.IM001_ScreenBroadcast;\n\nimport im.ivanl001.bigData.java_01.IMUtils.IMByteArr0NumUtils;\nimport im.ivanl001.bigData.java_01.Model.FrameUnit;\n\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.*;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-10-13 21:00\n * #description : 用来接受udp消息的一个类，继承Thread，重开线程\n **/\npublic class IMReceive extends Thread {\n\n    private static int SB_MAX_SIZE = 60 * 1024;\n    private DatagramSocket datagramSocket = null;\n    private DatagramPacket datagramPacket = null;\n\n    private byte[] buffer = new byte[SB_MAX_SIZE + 14];\n\n    private App app;\n\n    //这个有点不太好用，该用map，通过标号做key，到时候可以直接通过编号进行排序，因为标号是连续的\n//    private List<FrameUnit> frame = new ArrayList<>();\n    Map<Integer, FrameUnit> frame = new HashMap<>();\n\n\n    IMReceive(App app){\n        try {\n            datagramSocket = new DatagramSocket(8888);\n            this.app = app;\n        } catch (SocketException e) {\n            e.printStackTrace();\n        }\n        datagramPacket = new DatagramPacket(buffer, buffer.length);\n    }\n\n    @Override\n    public void run() {\n        try {\n\n            long lastTimeStamp = 0;\n\n            //一直循环的进行收取\n            while (true) {\n\n                datagramSocket.receive(datagramPacket);\n                int sliceLen = datagramPacket.getLength();//注意：这个长度不一定等于SB_MAX_SIZE, 因为最后一片有可能小于这个值\n\n\n                byte[] buffer01 = new byte[1024];\n\n                //在这里解析这个值，然后显示即可\n                //buffer，这个就是接受到的数据了\n                //注意：这里需要先进行解压缩buffer\n                ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(buffer);\n                ZipInputStream zipInputStream = new ZipInputStream(byteArrayInputStream);\n\n                ByteArrayOutputStream byteArrayOutputStream01 = new ByteArrayOutputStream();\n                ZipEntry zipEntry = null;\n                int len = 0;\n                while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n                    while ((len = zipInputStream.read(buffer01)) != -1) {\n                        byteArrayOutputStream01.write(buffer01, 0, len);\n                    }\n                }\n\n                byteArrayOutputStream01.close();\n                zipInputStream.close();\n                byteArrayInputStream.close();\n\n                byte[] theFrameUnitData = byteArrayOutputStream01.toByteArray();\n\n                FrameUnit frameUnit = convertBytesToFrameUnit(theFrameUnitData, theFrameUnitData.length);\n\n                //已经得到了frameUnit了， 判断frameUnit，如果属于同一帧，按照序号进行拼接，如果同一帧没有集齐，下一帧到了，那么直接舍弃没有集齐的那一帧\n                long currentTimestamp = frameUnit.getFrameId();\n\n                if (lastTimeStamp == currentTimestamp) {\n                    //时间戳相同，进行拼合，并更新lastTimeStamp\n                    frame.put(frameUnit.getNo(), frameUnit);\n                    lastTimeStamp = currentTimestamp;\n\n                } else {\n                    //时间戳不同，先清空图片数组，然后把当前的数据放入图片切片数组，并更新lastTimeStamp\n                    frame.clear();\n                    frame.put(frameUnit.getNo(), frameUnit);\n                    lastTimeStamp = currentTimestamp;\n                }\n\n                if (frameUnit.getCount() == frame.size()) {\n\n                    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n\n                    //说明已经集齐，那么把图片拼接起来就ok了\n                    for (int i=0;i<frame.size();i++) {\n                        FrameUnit frameUnit1 = frame.get(i);\n                        int sliceLen01 = frameUnit1.getDataLen();\n                        byte[] bytes = frameUnit1.getData();\n                        byteArrayOutputStream.write(bytes);\n                    }\n\n                    //在这里说明所有本帧的切片信息都已经被写入到byteArrayOutputStream了\n                    BufferedImage bufferedImage = ImageIO.read(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));\n\n                    ImageIO.write(bufferedImage, \"jpg\", new FileOutputStream(\"/Users/ivanl001/Desktop/to/capture/\" + frameUnit.getFrameId()+ \".jpg\"));\n\n                    app.updateIcon(byteArrayOutputStream.toByteArray());\n\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n\n    }\n\n    private FrameUnit convertBytesToFrameUnit(byte[] buffer, int sliceLen) {\n\n        //首先取出有效数据，因为buffer中很有可能有几个字节内容是无用内容\n        byte[] data = new byte[sliceLen];\n        System.arraycopy(buffer, 0, data, 0, sliceLen);\n        //这个时候data就是正确的需要的数据了,解析data到FrameUnit中即可\n\n\n        FrameUnit frameUnit = new FrameUnit();\n        //1，首先解析时间戳\n        frameUnit.setFrameId(IMByteArr0NumUtils.byteArr2long(data));//这里刚好是前八个是时间戳，所以不需要任何处理，把整个data放进去也可以处理\n\n        //2,解析切片个数，这里直接强转是没问题的，小转大不会丢失精度\n        frameUnit.setCount(data[8]);//这里会自动从字节转成int类型，从小往大转不会丢精度\n\n        //3,解析切片序号\n        frameUnit.setNo(data[9]);\n\n        //4,解析数据长度，4个字节数组转int\n        int theDataLen = IMByteArr0NumUtils.byteArr2Int(data, 10);\n        System.out.println(\"数据的长度是：\" + theDataLen);\n        frameUnit.setDataLen(theDataLen);\n\n        //5,解析data\n        byte[] theData = new byte[theDataLen];\n\n        System.arraycopy(buffer, 14, theData, 0, theDataLen);\n        frameUnit.setData(theData);\n\n        return frameUnit;\n    }\n}\n```"
    },
    {
      "type": "markdown",
      "data": "## 5，TCP的一个小程序"
    },
    {
      "type": "markdown",
      "data": "### 5.1，ServerApp服务器端01"
    },
    {
      "type": "markdown",
      "data": "```java\npackage im.ivanl001.bigData.java_01.Java.IM002_TCP;\n\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-10-14 20:07\n * #description :\n **/\npublic class ServerApp {\n\n    //这里需要维护一个连接的用户信息\n    private static Map<String, Socket> connectedUser = new HashMap<>();\n\n    public static void main(String[] args) throws IOException {\n\n        ServerSocket serverSocket = new ServerSocket(8888);\n        Socket socket =null;\n        System.out.println(\"服务器开始，端口号是：\" + serverSocket.getLocalPort());\n\n        while (true) {\n            socket = serverSocket.accept();\n            String ipStr = socket.getInetAddress().getHostAddress();\n            int port     = socket.getPort();\n            String connectedUserKey = ipStr + \":\" + port;\n\n            System.out.println(\"用用户连接，用户的连接key是 ：\" + connectedUserKey);\n            connectedUser.put(connectedUserKey, socket);\n\n            IM_TCP_Server_Thread serverThread =new IM_TCP_Server_Thread(socket, connectedUser);\n            serverThread.start();\n\n            System.out.println(\"客户端连接的数量：\"+connectedUser.size());\n        }\n    }\n\n}\n```"
    },
    {
      "type": "markdown",
      "data": "### 5.2, IM_TCP_Server_Thread,服务器端02\n`01中的主程序每次接收到客户端的连接请求，都会通过这个类进行创建新的线程，然后进行发送数据或者接受数据`"
    },
    {
      "type": "markdown",
      "data": "```java\npackage im.ivanl001.bigData.java_01.Java.IM002_TCP;\n\nimport im.ivanl001.bigData.java_01.IMUtils.IMByteArr0NumUtils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Socket;\nimport java.util.Map;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-10-14 20:06\n * #description : 服务器线程，也就是每次收到一个连接就建立一个新的线程\n **/\npublic class IM_TCP_Server_Thread extends Thread {\n\n    private Socket socket;\n    private Map<String, Socket> connectedUser;\n\n    public IM_TCP_Server_Thread(Socket socket, Map<String, Socket> connectedUser) {\n        this.socket = socket;\n        this.connectedUser = connectedUser;\n    }\n\n    @Override\n    public void run() {\n\n        System.out.println(\"-----------------开始接受消息---------------\");\n\n        while (true) {\n            //在这里解析客户端发送的消息\n            try {\n\n                InputStream inputStream = socket.getInputStream();\n\n                //因为如果不指定协议的话，你是不知道这条数据的长度的，所以就不能进行读取了\n                byte[] msgLenBytes = new byte[4];\n                inputStream.read(msgLenBytes);\n                int msgLen = IMByteArr0NumUtils.byteArr2Int(msgLenBytes);\n                System.out.println(\"消息长度是:\" + msgLen);\n\n                byte[] msgBytes = new byte[msgLen];\n                inputStream.read(msgBytes);\n                String string = new String(msgBytes);\n\n                System.out.println(\"接收到客户端消息：\" + string);\n\n\n                //在这里找到所有的连接的socket，把这个发送其他的socket\n                int currentPort = socket.getPort();\n                for (Socket socket : connectedUser.values()) {\n                    //这里直接把消息转发给所有的客户端，包括自己\n                    IMSocketUtils.sendMsg(string, socket);\n                }\n\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n```"
    },
    {
      "type": "markdown",
      "data": "### 5.3，ClientApp客户端01\n"
    },
    {
      "type": "markdown",
      "data": "```java\npackage im.ivanl001.bigData.java_01.Java.IM002_TCP;\n\nimport java.io.IOException;\nimport java.net.Socket;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-10-14 20:27\n * #description : 客户端入口\n **/\npublic class ClientApp {\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n\n        //1,设置socket服务器地址和端口，这里的host和port都是服务器的\n        Socket socket_client = new Socket(\"localhost\", 8888);\n\n        //2,发送消息\n        IM_TCP_Client_Thread client_thread = new IM_TCP_Client_Thread(socket_client);\n        client_thread.start();\n\n        //3, 主线cheng主线程主要交给ui做一些其他方面的事情\n        int i = 0;\n        while (true) {\n            i += 1;\n            //System.out.println(\"更新UI\" + i);\n            Thread.sleep(10000);\n        }\n    }\n\n}\n```"
    },
    {
      "type": "markdown",
      "data": "### 5.4, 客户端02\n`这个也是每次接受到服务器的不同socket创建线程用的`"
    },
    {
      "type": "markdown",
      "data": "```java\npackage im.ivanl001.bigData.java_01.Java.IM002_TCP;\n\nimport java.net.Socket;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-10-14 20:22\n * #description : tcp连接客户端线程\n **/\npublic class IM_TCP_Client_Thread extends Thread {\n\n    private Socket socket;\n\n    IM_TCP_Client_Thread(Socket socket) {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        super.run();\n\n        new Thread(){\n            @Override\n            public void run() {\n                while (true) {\n                    //在这里循环接受消息\n                    IMSocketUtils.receiveMsg(socket);\n\n                }\n            }\n        }.start();\n\n\n        /*//在这里发送消息\n        System.out.print(\"Enter your msg:\");\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入你的姓名：\");\n        String name = scanner.nextLine();\n        System.out.println(\"输入的内容是：\" + name);\n        sendMsg(name);*/\n\n        //这里是发消息\n        int i = 0;\n        while (true) {\n            //sendMsg(\"ivanl00\" + i);\n            IMSocketUtils.sendMsg(\"ivanl00\" + i, socket);\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            i += 1;\n        }\n    }\n\n    /*public void sendMsg(String msg) {\n\n        try {\n\n            //我们是需要指定发送的协议的，数据长度需要包含在发送的数据包中，要不然接收的socket是不知道如何进行解析的\n            int msgLen = msg.getBytes().length;\n            //把长度转换成四个长度的字节数组，写入到数据中\n            byte[] msgLenBytes = IMByteArr0NumUtils.int2byteArr(msgLen);\n            byte[] msgBytes = msg.getBytes();\n            byte[] msgPack = new byte[4 + msgLen];//消息的长度加上4个字节的长度，这四个字节是用来记录消息的长度信息的\n            System.arraycopy(msgLenBytes, 0, msgPack, 0, 4);\n            System.arraycopy(msgBytes, 0, msgPack, 4, msgLen);\n\n            socket.getOutputStream().write(msgPack);\n            socket.getOutputStream().flush();\n            System.out.println(\"client:\" + msg);\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }*/\n\n}\n```"
    },
    {
      "type": "markdown",
      "data": "### 5.5, 封装的IMSocketUtils工具类，上面可能会需要用的"
    },
    {
      "type": "markdown",
      "data": "```java\npackage im.ivanl001.bigData.java_01.Java.IM002_TCP;\n\nimport im.ivanl001.bigData.java_01.IMUtils.IMByteArr0NumUtils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Socket;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-10-15 19:23\n * #description :\n **/\npublic class IMSocketUtils {\n\n    public static void receiveMsg(Socket socket) {\n        while (true) {\n            //在这里解析客户端发送的消息\n            try {\n                InputStream inputStream = socket.getInputStream();\n\n                //因为如果不指定协议的话，你是不知道这条数据的长度的，所以就不能进行读取了\n                byte[] msgLenBytes = new byte[4];\n                inputStream.read(msgLenBytes);\n                int msgLen = IMByteArr0NumUtils.byteArr2Int(msgLenBytes);\n                System.out.println(\"消息长度是:\" + msgLen);\n\n                byte[] msgBytes = new byte[msgLen];\n                inputStream.read(msgBytes);\n                String string = new String(msgBytes);\n\n                System.out.println(\"接收到客户端消息：\" + string);\n\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n\n    public static void sendMsg(String msg, Socket socket) {\n\n        try {\n\n            //我们是需要指定发送的协议的，数据长度需要包含在发送的数据包中，要不然接收的socket是不知道如何进行解析的\n            int msgLen = msg.getBytes().length;\n            //把长度转换成四个长度的字节数组，写入到数据中\n            byte[] msgLenBytes = IMByteArr0NumUtils.int2byteArr(msgLen);\n            byte[] msgBytes = msg.getBytes();\n            byte[] msgPack = new byte[4 + msgLen];//消息的长度加上4个字节的长度，这四个字节是用来记录消息的长度信息的\n            System.arraycopy(msgLenBytes, 0, msgPack, 0, 4);\n            System.arraycopy(msgBytes, 0, msgPack, 4, msgLen);\n\n            socket.getOutputStream().write(msgPack);\n            socket.getOutputStream().flush();\n            System.out.println(\"client:\" + msg);\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
    }
  ]
}