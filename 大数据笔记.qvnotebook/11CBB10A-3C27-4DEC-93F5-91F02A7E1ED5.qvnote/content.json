{
  "title": "01-Java基础-0102-自定义归档协议",
  "cells": [
    {
      "type": "markdown",
      "data": "> 简单解释以下：这里就是想把多个文件通过一定的协议写入到一个文件，然后再通过该协议，将文件从单个文件读取出来\n> 协议如下：\n\n归档：\n> 1, 取前四个字节，用来存储文件名字的长度\n> 2, 取文件名字长度的字节， 用来存储文件名字\n> 3, 取四个字节，用来存储文件内容的长度\n> 4, 取文件内容的长度的字节， 用来存储文件内容\n> 5, 如果还有文件需要归档，重复1-4操作\n\n解归档：\n> 1, 先读取四个字节，解析出该数字，也就是文件名字的字节长度\n> 2, 1中取到文件名字的长度，追加读取该长度的字节，可以解析出文件名\n> 3, 追加读取四个字节的长度，解析出文件长度\n> 4, 追加读取文件长度字节的内容，解析出文件内容\n> 5，如果文件还有内容，重复1-4操作\n"
    },
    {
      "type": "markdown",
      "data": "* 下面直接上代码"
    },
    {
      "type": "markdown",
      "data": "```\npackage im.ivanl001.bigData.java_01;\n\nimport im.ivanl001.bigData.java_01.IMUtils.IMArchiveAndUnarchiveUtils;\nimport org.junit.Test;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-10-12 10:12\n * #description : 自定义归档和解归档\n **/\npublic class A05_Archive0UnArchive {\n\n\n    @Test\n    public void archiveTest(){\n        String fromPath01 = \"/Users/ivanl001/Desktop/from/01.jpg\";\n        String fromPath02 = \"/Users/ivanl001/Desktop/from/02.jpg\";\n        String fromPath03 = \"/Users/ivanl001/Desktop/from/03.jpg\";\n        String fromPath04 = \"/Users/ivanl001/Desktop/from/04.jpg\";\n        String fromPath05 = \"/Users/ivanl001/Desktop/from/05.jpg\";\n        String fromPath06 = \"/Users/ivanl001/Desktop/from/zhang.txt\";\n\n        String toPath = \"/Users/ivanl001/Desktop/to/archive.zbl\";\n\n        String[] path = new String[6];\n        path[0] = fromPath01;\n        path[1] = fromPath02;\n        path[2] = fromPath03;\n        path[3] = fromPath04;\n        path[4] = fromPath05;\n        path[5] = fromPath06;\n\n        IMArchiveAndUnarchiveUtils.archiveToZBL(path, \"/Users/ivanl001/Desktop/to\");\n\n    }\n\n    //搞定，可以归档，可以解归档，good！\n    @Test\n    public void unarchiveTest(){\n\n        String filePath = \"/Users/ivanl001/Desktop/to/from.zbl\";\n        IMArchiveAndUnarchiveUtils.unarchive(filePath);\n\n    }\n}\n\n```"
    },
    {
      "type": "markdown",
      "data": "```\npackage im.ivanl001.bigData.java_01.IMUtils;\n\nimport im.ivanl001.bigData.java_01.Model.IMFile;\n\nimport java.io.*;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-10-12 10:33\n * #description : 张不二的归档和解归档工具\n **/\npublic class IMArchiveAndUnarchiveUtils {\n\n    public static final String suffix = \".zbl\";\n\n    public static void archiveToZBL(String[] fromPath, String toPath) {\n\n        for (int i=0;i<fromPath.length;i++) {\n\n            File file = new File(fromPath[i]);\n            String[] parentArr = file.getParent().split(\"/\");\n            String folderName = parentArr[parentArr.length-1];\n\n\n            //---------获取所需要的字节信息\n            String name = file.getName();\n            //文件名长度\n            int nameLen = name.getBytes().length;//名字长度\n            byte[] nameLenByteArr = IMByteArr0NumUtils.int2byteArr(nameLen);\n            //文件名字节数组\n            byte[] nameByte = name.getBytes();   //名字字节数组\n            //文件长度\n            int dataLen = (int) file.length();    //文件长度\n            byte[] dataLenByteArr = IMByteArr0NumUtils.int2byteArr(dataLen);\n            //文件自字节数组\n            byte[] dataByteArr = buildData(file);\n\n            int total = 4 + nameLen + 4 + dataLen;//第一个4字节长度用来存放名字长度信息，第二个4用来存放数据长度信息\n\n            //----------把需要的字节信息写入到一个字节数组中\n            byte[] theFinalDataByteArr = new byte[total];\n            System.arraycopy(nameLenByteArr, 0, theFinalDataByteArr, 0, 4);\n            System.arraycopy(nameByte, 0, theFinalDataByteArr, 4, nameLen);\n            System.arraycopy(dataLenByteArr, 0, theFinalDataByteArr, 4 + nameLen, 4);\n\n            System.arraycopy(dataByteArr, 0, theFinalDataByteArr, 4 + nameLen + 4, dataLen);\n\n\n            String finalToPath = toPath + \"/\" + folderName + suffix;\n            System.out.println(finalToPath);\n\n            try {\n                BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(finalToPath, true));\n                bufferedOutputStream.write(theFinalDataByteArr);\n                bufferedOutputStream.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static byte[] buildData(File file) {\n\n        BufferedInputStream bufferedInputStream = null;\n        ByteArrayOutputStream byteArrayOutputStream = null;\n\n        try {\n\n            FileInputStream fileInputStream = new FileInputStream(file);\n            bufferedInputStream = new BufferedInputStream(fileInputStream);\n\n            byteArrayOutputStream = new ByteArrayOutputStream();\n            byte[] bytes = new byte[1024];\n\n            int len = 0;\n            while ((len = bufferedInputStream.read(bytes)) != -1) {\n                byteArrayOutputStream.write(bytes, 0, len);\n            }\n            return byteArrayOutputStream.toByteArray();\n\n        } catch (Exception e) {\n            System.out.println(e);\n            return null;\n        } finally {\n            try {\n                bufferedInputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            try {\n                byteArrayOutputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n        }\n\n    }\n\n    public static void unarchive(String path) {\n\n        //1，读取文件，并设定好输出文件夹等\n        File file = new File(path);\n        String baseDir = file.getParent();\n        String name = file.getName();\n        String folderPath = baseDir + \"/\" + name.split(\"zbl\")[0];\n        File file1 = new File(folderPath);\n        if (!file1.isDirectory()) {\n            file1.mkdir();\n        }\n\n        //2,设定输入流对象，方便读取文件并进行解析\n        BufferedInputStream bufferedInputStream = null;\n        try {\n            bufferedInputStream = new BufferedInputStream(new FileInputStream(file));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        //3, 开始正式解析归档文件，并读取一个写一个到文件中\n        //如果没读到-1，就接着循环\n        while (true) {\n\n            IMFile imFile = readData(bufferedInputStream);\n            if (imFile == null) {\n                try {\n                    bufferedInputStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                break;\n\n            }\n\n            BufferedOutputStream bufferedOutputStream = null;\n            try {\n                String finalFileName = folderPath + \"/\" + imFile.getFileName();\n                bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(finalFileName));\n                bufferedOutputStream.write(imFile.getFileContent());\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    bufferedOutputStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            System.out.println(\"读取一个文件～～\");\n        }\n        //return null;\n    }\n\n    public static IMFile readData(BufferedInputStream bufferedInputStream){\n\n        try {\n\n            //1，首先先读取四个字节的内容，这个是第一个被归档的文件名字的长度\n            byte[] nameLenByteArr = new byte[4];\n            int res = bufferedInputStream.read(nameLenByteArr);\n            if (res == -1) {\n                return null;\n            }\n            int nameLen = IMByteArr0NumUtils.byteArr2Int(nameLenByteArr);\n\n            //2, 根据第一步中取出的文件名字的长度，再从后面追加读取这个长度的内容，然后文件名字就知道了\n            byte[] nameByte = new byte[nameLen];\n            int res01 = bufferedInputStream.read(nameByte);\n            if (res01 == -1) {\n                return null;\n            }\n            String name = new String(nameByte);\n\n            //3, 然后再追加读取四个自己的内容，这个内容是第二步中文件名对应文件的长度\n            byte[] dataLenByteArr = new byte[4];\n            int res02 = bufferedInputStream.read(dataLenByteArr);\n            if (res02 == -1) {\n                return null;\n            }\n            int dataLen = IMByteArr0NumUtils.byteArr2Int(dataLenByteArr);\n\n            //4, 再追加读取3步中的长度内容，那么第一个归档的文件就完成读取，写出到文件中即可\n            byte[] dataByteArr = new byte[dataLen];\n            int res03 = bufferedInputStream.read(dataByteArr);\n            if (res03 == -1) {\n                return null;\n            }\n\n            return new IMFile(name, dataByteArr);\n\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n\n```"
    }
  ]
}