{
  "title": "12-Scala-0107-scala学习",
  "cells": [
    {
      "type": "markdown",
      "data": "\n# Scala基础01\n\n\n## lazy的用法\n\n> 1, 比如说从文件中读取内容，会直接把文件内容读到变量中去\n\n```scala\n val textStr = scala.io.Source.fromFile(\"/Users/ivanl001/Desktop/test.txt\").mkString;\n```\n\n> 2, 如果说不需要立即读取，而是有需求的当用到的时候再进行读取进去，那么就可以用lazy,还有这里只能用val，var是不能用lazy修饰的，因为可变\n\n```scala\nlazy val textStr = scala.io.Source.fromFile(\"/Users/ivanl001/Desktop/test.txt\").mkString;\n\ntextStr: String = <lazy>\n```\n\n\n## 异常相关处理等\n\n> 和java其实是类似的\n\n```scala\n\nimport java.io.IOException\n\ntry{\n  val textStr = scala.io.Source.fromFile(\"/Users/ivanl001/Desktop000aa/test.txt\").mkString;\n  print(textStr);\n}catch{\n  case ex: IOException =>  print(ex)\n  case _:Exception =>  print(\"catch exception\")\n}\n\n```\n\n> 1 to 10 :_* //这个的意思是把1 到 10转成序列\n\n## 数组相关\n\n### 创建定长数组\n\n```scala\nval nums = new Array[Int](10)\n//10个整数的数组， 所有元素的初始化是0\n\nval a = new Array[String](10)\n//10个字符串的数组， 所有元素的初始化是null\n\nval s = Array(\"Hello\", \"World\")\n// 已经提供初始值的化就不需要new\n```\n\n### 操作定长数组元素，包括赋值和访问\n\n```\n//设置元素\ns(0) = \"Goodbye\"\n\n//取出某个元素\ns(0)\n```\n\n\n### 创建变长数组\n```scala\nimport scala.collection.mutable.ArrayBuffer\n\nval b = ArrayBuffer[Int]()\n\n//在尾部添加元素\nb += 1\n// ArrayBuffer(1)\n\n//在尾部添加多个元素\nb += (1, 2, 3, 5)\n// ArrayBuffer(1, 1, 2, 3, 5)\n\n//++=追加集合\nb ++= Array(8, 13, 21)\n// ArrayBuffer(1, 1, 2, 3, 5, 8, 13, 21)\n\n//移除元素\nb.trimEnd(5)\n// ArrayBuffer(1, 1, 2)\n\n//移除头部一个元素\n//b.trimStart(1)\n\n\nb.insert(2, 6)\n// ArrayBuffer(1, 1, 6, 2)\n\nb.insert(2, 7, 8, 9)\n// ArrayBuffer(1, 1, 7, 8, 9, 6, 2)\n\nb.remove(2)\n// ArrayBuffer(1, 1, 8, 9, 6, 2)\n\nb.remove(2, 3)\n// ArrayBuffer(1, 1, 2)\n\nval c = b.toArray\n//c就是定长数组\n\nfor (i <- 0 until a.length)\n        println(i + \": \" + a(i))\n\n//遍历定长数组\nfor(i <- 0 until c.length) println(c(i))\n\n//遍历可变数组\n for(i <- 0 until b.length) println(b(i))\n\n```\n\n### 数组转换\n\n```Scala\nval a = Array(2, 3, 5, 7, 11);\nval result = for (elem <- a) yield 2 * elem;\n// result Array(4, 6, 10, 14, 22);\n\n//如果想要丢掉奇树位置的数字：\nvar result01 = for (elem <- a if elem % 2 == 0) yield 2 * elem;\n\n//创建一个数组\nval a = Array(0 to 10:_*)\n//过滤后重组然后生成新的数组\nval b = a.filter(_ % 2 == 0).map(_ * 2)\n//Array[Int] = Array(0, 4, 8, 12, 16, 20)\n\n//第一种方式获取偶数数组，而且还可以运算后返回\nval a = for (i <- 0 until 10 if i%2 == 0) yield i;\nval a = for (i <- 0 until 10 if i%2 == 0) yield i*2;\n\n//第二种方式\nval b = Array(1 to 10 :_*);\n//b: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nb.filter(_%2 == 0).map(_ * 2);\n//res15: Array[Int] = Array(4, 8, 12, 16, 20)\n```\n\n### 数组的其他方法\n```scala\n//求和\nArray(9,8,7).sum\n\nArray(9,8,7).max\n\nArray(9,8,7).min\n\nArray(\"Mary\", \"had\", \"a\", \"little\", \"lamb\").max\n\n\n//排序\nval b = ArrayBuffer(1, 7, 2, 9)\n//val bSorted = b.sorted(_ < _)//这种排序貌似是有问题的\nval bSorted = b.sorted();\n\n\nval a = Array(1, 7, 2, 9)\n//quickSort返回值是空，是对a数组进行排序\nscala.util.Sorting.quickSort(a)\n\n\na.mkString(\" and \")\n// \"1 and 2 and 7 and 9\"\na.mkString(\"<\", \",\", \">\")\n// \"<1,2,7,9>\"\n\n\n```\n\n### 多维数组\n\n```scala\n//创建数组\nval matrix = Array.ofDim[Int](2,4);\n\n//赋值某个元素\nmatrix(0) = Array(0,2,3,4);\n\n//取值\nmatrix(0)(2)\n\n//创建数组\nvar matrix01 = new Array[Array[Int]](4);\n\n//赋值某个元素\nmatrix01[0] = Array(0,2,3,4,5,7);\n\n//如果取未赋值的时候，会报错java.lang.NullPointerException\n\n//遍历\nfor (arr <- matrix01) {println(arr)};\n//或者\nfor (i <- 0 until matrix01.length) {println(matrix01(i))};\n\n\n```\n\n## 3.8 与java的互操作\n略"
    }
  ]
}