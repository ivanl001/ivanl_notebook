{
  "title": "07-HBase-0307-Hbase过滤器的java的api",
  "cells": [
    {
      "type": "markdown",
      "data": "*直接看代码中注释*"
    },
    {
      "type": "markdown",
      "data": "```java\npackage im.ivanl001.bigData.Hbase;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.hbase.CompareOperator;\nimport org.apache.hadoop.hbase.HBaseConfiguration;\nimport org.apache.hadoop.hbase.TableName;\nimport org.apache.hadoop.hbase.client.*;\nimport org.apache.hadoop.hbase.filter.*;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.util.*;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-11-12 19:42\n * #description : 过滤器的使用\n **/\npublic class A05_Filter {\n\n\n    //########------建议先看一下最下面那个， 那个比较全一些------#############\n\n    //这里因为之前想同时设置两个filter的时候，后者会覆盖前者，所以不能成功，这里用FilterList可以实现，如下\n    @Test\n    public void hbase_familyFilter00000_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t2\");\n        Table table = connection.getTable(tableName);\n\n        //终于明白了这里设置一个scan的作用是什么了，可以设置过滤器呀\n        Scan scan = new Scan();\n        //注意：如果添加列族，那么只会扫描指定列族的内容，如果没有添加，会扫描所有列族\n        //scan.addColumn(\"f1\".getBytes(), \"name\".getBytes());\n        //scan.addColumn(\"f2\".getBytes(), \"age\".getBytes());\n\n        //\n        Filter filter = new FamilyFilter(CompareOperator.EQUAL, new BinaryComparator(\"f2\".getBytes()));\n        Filter filter01 = new RowFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"r0001000\".getBytes()));\n        //如果连续添加过滤器，后者会覆盖前者！！！！！！！\n        /*scan.setFilter(filter01);\n        scan.setFilter(filter);*/\n\n\n        List<Filter> filters = new ArrayList<Filter>();\n        filters.add(filter);\n        filters.add(filter01);\n\n\n        //FilterList构造器需要一个Filter的list\n        FilterList filterList = new FilterList(filters);\n\n\n        scan.setFilter(filterList);\n\n\n        ResultScanner resultScanner = table.getScanner(scan);\n        Iterator<Result> results = resultScanner.iterator();\n\n        while (results.hasNext()) {\n\n            Result result = results.next();\n            //因为我们这里想要获取所有列族的数据，所以不能像上面那样指定具体的某一列族了\n            NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n            for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n                byte[] familyKey = entry.getKey();\n                NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n                for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                    byte[] columnKey = entry1.getKey();\n                    NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                    //对于一个具体的列，可能还有不同的版本\n                    for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                        Long versionKey = entry2.getKey();\n                        byte[] versionValue = entry2.getValue();\n                        System.out.println(\"列族：\"+ new String(familyKey) + \", 列：\" + new String(columnKey) + \",版本号：\" + versionKey + \",值是：\" + new String(versionValue));\n                    }\n                }\n            }\n        }\n\n        resultScanner.close();\n\n\n    }\n\n\n\n\n    //这个是个静态方法，懒得重复拷贝，所以直接抽取出来放在这里方便调用\n    public static void func(Filter filter) throws Exception {\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t4\");\n        Table table = connection.getTable(tableName);\n\n        //终于明白了这里设置一个scan的作用是什么了，可以设置过滤器呀\n        Scan scan = new Scan();\n        scan.setFilter(filter);\n\n        ResultScanner resultScanner = table.getScanner(scan);\n        Iterator<Result> results = resultScanner.iterator();\n\n        while (results.hasNext()) {\n\n            Result result = results.next();\n            //因为我们这里想要获取所有列族的数据，所以不能像上面那样指定具体的某一列族了\n            NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n            for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n                byte[] familyKey = entry.getKey();\n                NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n                for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                    byte[] columnKey = entry1.getKey();\n                    NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                    //对于一个具体的列，可能还有不同的版本\n                    for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                        Long versionKey = entry2.getKey();\n                        byte[] versionValue = entry2.getValue();\n                        System.out.println(\"列族：\"+ new String(familyKey) + \", 列：\" + new String(columnKey) + \",版本号：\" + versionKey + \",值是：\" + new String(versionValue));\n                    }\n                }\n            }\n        }\n        resultScanner.close();\n    }\n\n\n\n    //实现like类似的功能\n    @Test\n    public void hbase_like_similar_test() throws Exception {\n\n        //这个可以r002%这样的效果\n        Filter filter = new ValueFilter(CompareOperator.EQUAL, new RegexStringComparator(\"^r002\"));\n        func(filter);\n\n    }\n\n\n\n\n\n    //大多类似，剩下的挑选进行代码演示\n    @Test\n    public void hbase_ColumnCountGetFilter_test() throws Exception {\n        //取前2列\n        Filter filter = new ColumnCountGetFilter(2);\n        func(filter);\n    }\n\n\n\n\n\n    // 只有键值，没有值的\n    @Test\n    public void hbase_KeyOnlyFilter_test() throws Exception {\n        //列族：f1, 列：name,版本号：1542074141465,值是：\n        Filter filter = new KeyOnlyFilter();\n        func(filter);\n\n    }\n\n\n\n    @Test\n    public void hbase_PageFilter_test() throws Exception {\n\n        //就取前1条， 这个是按区来限定的， 如果有三个区， 就是每个区上限取两个了\n        Filter filter = new PageFilter(2);\n        func(filter);\n        //在这个基础上也可以使用scan的startwithrow还是叫什么的方法， 来限定开始行和结束行\n\n    }\n\n\n\n\n\n\n\n    @Test\n    public void hbase_PrefixFilter_test() throws Exception {\n\n        //r做前缀的， r001, 我这张表中添加了类似r001， r002， s001之类的rowkey\n        Filter filter = new PrefixFilter(\"r\".getBytes());//\n        func(filter);\n\n    }\n\n\n\n\n    @Test\n    public void hbase_singleComlumnValueExcludeFilter_test() throws Exception {\n\n        //这里设定如果f1列族的age小于3，那么这一行就会被过滤掉, 该行作为过滤条件，也是不显示，也就是会被直接过滤掉\n        Filter filter = new SingleColumnValueExcludeFilter(\"f1\".getBytes(), \"age\".getBytes(), CompareOperator.GREATER, \"30\".getBytes());\n        func(filter);\n\n\n    }\n\n\n\n\n\n    //单行值过滤，如果这个值不满足，整行都会被过滤掉，注意：过滤条件这个列也会被过滤掉，也就是不显示的哈\n    @Test\n    public void habse_singleColumnValueFilter_test() throws Exception {\n\n        //这里设定如果f1列族的age小于3，那么这一行就会被过滤掉, 第二行全部显示， 可以参考对比下 上面的SingleColumnValueExcludeFilter\n        Filter filter = new SingleColumnValueFilter(\"f1\".getBytes(), \"age\".getBytes(), CompareOperator.GREATER, \"30\".getBytes());\n        func(filter);\n    }\n\n\n\n\n    //这个居然每讲完😢😢😢\n    @Test\n    public void hbase_dependentColumnFilter_test() throws Exception {\n\n        //这里好像也不对\n        //不知道这个是干嘛用的， 怎么设置都没有东西，算了，估计也是废的\n        Filter filter = new DependentColumnFilter(\"f1\".getBytes(), \"age\".getBytes(), false, CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"10\".getBytes()));\n//        scan.setFilter(filter);\n        func(filter);\n    }\n\n\n\n\n\n\n    //对get设置qualifierFilter过滤器\n    @Test\n    public void hbase_valueFileter01_test() throws Exception {\n\n\n        //\n        //Filter filter01 = new RowFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"r0001000\".getBytes()));\n        Filter filter = new ValueFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"ivanl0000100\".getBytes()));\n\n\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t2\");\n        Table table = connection.getTable(tableName);\n\n\n\n        Get get = new Get(\"r0000001\".getBytes());\n        get.setFilter(filter);\n\n\n        Result result = table.get(get);\n\n        //因为我们这里想要获取所有列族的数据，所以不能像上面那样指定具体的某一列族了\n        NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n        for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n            byte[] familyKey = entry.getKey();\n            NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n            for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                byte[] columnKey = entry1.getKey();\n                NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                //对于一个具体的列，可能还有不同的版本\n                for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                    Long versionKey = entry2.getKey();\n                    byte[] versionValue = entry2.getValue();\n                    System.out.println(\"列族：\"+ new String(familyKey) + \", 列：\" + new String(columnKey) + \",版本号：\" + versionKey + \",值是：\" + new String(versionValue));\n                }\n            }\n        }\n    }\n\n\n\n\n\n\n    //对scan设置valueFileter过滤器\n    @Test\n    public void hbase_valueFileter_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t2\");\n        Table table = connection.getTable(tableName);\n\n        //终于明白了这里设置一个scan的作用是什么了，可以设置过滤器呀\n        Scan scan = new Scan();\n\n        //\n        Filter filter = new ValueFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"ivanl0000010\".getBytes()));\n        scan.setFilter(filter);\n\n\n        ResultScanner resultScanner = table.getScanner(scan);\n        Iterator<Result> results = resultScanner.iterator();\n\n        while (results.hasNext()) {\n\n            Result result = results.next();\n            //因为我们这里想要获取所有列族的数据，所以不能像上面那样指定具体的某一列族了\n            NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n            for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n                byte[] familyKey = entry.getKey();\n                NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n                for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                    byte[] columnKey = entry1.getKey();\n                    NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                    //对于一个具体的列，可能还有不同的版本\n                    for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                        Long versionKey = entry2.getKey();\n                        byte[] versionValue = entry2.getValue();\n                        System.out.println(\"列族：\"+ new String(familyKey) + \", 列：\" + new String(columnKey) + \",版本号：\" + versionKey + \",值是：\" + new String(versionValue));\n                    }\n                }\n            }\n        }\n\n        resultScanner.close();\n    }\n\n\n\n\n\n\n    //对get设置qualifierFilter过滤器\n    @Test\n    public void hbase_qualifierFilter01_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t2\");\n        Table table = connection.getTable(tableName);\n\n        //\n        //Filter filter01 = new RowFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"r0001000\".getBytes()));\n        Filter filter = new QualifierFilter(CompareOperator.EQUAL, new BinaryComparator(\"age\".getBytes()));\n\n\n        Get get = new Get(\"r0000001\".getBytes());\n        get.setFilter(filter);\n\n\n        Result result = table.get(get);\n\n        //因为我们这里想要获取所有列族的数据，所以不能像上面那样指定具体的某一列族了\n        NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n        for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n            byte[] familyKey = entry.getKey();\n            NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n            for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                byte[] columnKey = entry1.getKey();\n                NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                //对于一个具体的列，可能还有不同的版本\n                for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                    Long versionKey = entry2.getKey();\n                    byte[] versionValue = entry2.getValue();\n                    System.out.println(\"列族：\"+ new String(familyKey) + \", 列：\" + new String(columnKey) + \",版本号：\" + versionKey + \",值是：\" + new String(versionValue));\n                }\n            }\n        }\n    }\n\n\n\n\n\n\n\n\n    //对scan设置qualifierFilter过滤器\n    @Test\n    public void hbase_qualifierFilter_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t2\");\n        Table table = connection.getTable(tableName);\n\n        //终于明白了这里设置一个scan的作用是什么了，可以设置过滤器呀\n        Scan scan = new Scan();\n        //注意：如果添加列族，那么只会扫描指定列族的内容，如果没有添加，会扫描所有列族\n        //scan.addColumn(\"f1\".getBytes(), \"name\".getBytes());\n        //scan.addColumn(\"f2\".getBytes(), \"age\".getBytes());\n\n        //\n        //Filter filter01 = new RowFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"r0001000\".getBytes()));\n        Filter filter = new QualifierFilter(CompareOperator.EQUAL, new BinaryComparator(\"age\".getBytes()));\n\n        //如果连续添加过滤器，后者会覆盖前者！！！！！！！\n        //scan.setFilter(filter01);\n        scan.setFilter(filter);\n\n\n        ResultScanner resultScanner = table.getScanner(scan);\n        Iterator<Result> results = resultScanner.iterator();\n\n        while (results.hasNext()) {\n\n            Result result = results.next();\n            //因为我们这里想要获取所有列族的数据，所以不能像上面那样指定具体的某一列族了\n            NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n            for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n                byte[] familyKey = entry.getKey();\n                NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n                for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                    byte[] columnKey = entry1.getKey();\n                    NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                    //对于一个具体的列，可能还有不同的版本\n                    for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                        Long versionKey = entry2.getKey();\n                        byte[] versionValue = entry2.getValue();\n                        System.out.println(\"列族：\"+ new String(familyKey) + \", 列：\" + new String(columnKey) + \",版本号：\" + versionKey + \",值是：\" + new String(versionValue));\n                    }\n                }\n            }\n        }\n\n        resultScanner.close();\n    }\n\n\n\n\n\n    //对scan设置familyFilter过滤器\n    @Test\n    public void hbase_familyFilter01_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t2\");\n        Table table = connection.getTable(tableName);\n\n        Get get = new Get(\"r0000001\".getBytes());\n\n\n        Filter filter = new FamilyFilter(CompareOperator.EQUAL, new BinaryComparator(\"f2\".getBytes()));\n        //Filter filter01 = new RowFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"r0001000\".getBytes()));\n        //这个就是在get上添加过滤器\n        get.setFilter(filter);\n\n\n        Result result = table.get(get);\n        //因为我们这里想要获取所有列族的数据，所以不能像上面那样指定具体的某一列族了\n        NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n        for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n            byte[] familyKey = entry.getKey();\n            NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n            for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                byte[] columnKey = entry1.getKey();\n                NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                //对于一个具体的列，可能还有不同的版本\n                for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                    Long versionKey = entry2.getKey();\n                    byte[] versionValue = entry2.getValue();\n                    System.out.println(\"列族：\"+ new String(familyKey) + \", 列：\" + new String(columnKey) + \",版本号：\" + versionKey + \",值是：\" + new String(versionValue));\n                }\n            }\n        }\n\n\n\n\n    }\n\n\n\n\n\n    //对scan设置familyFilter过滤器\n    @Test\n    public void hbase_familyFilter_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t2\");\n        Table table = connection.getTable(tableName);\n\n        //终于明白了这里设置一个scan的作用是什么了，可以设置过滤器呀\n        Scan scan = new Scan();\n        //注意：如果添加列族，那么只会扫描指定列族的内容，如果没有添加，会扫描所有列族\n        //scan.addColumn(\"f1\".getBytes(), \"name\".getBytes());\n        //scan.addColumn(\"f2\".getBytes(), \"age\".getBytes());\n\n        //\n        Filter filter = new FamilyFilter(CompareOperator.EQUAL, new BinaryComparator(\"f2\".getBytes()));\n        Filter filter01 = new RowFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"r0001000\".getBytes()));\n        //如果连续添加过滤器，后者会覆盖前者！！！！！！！\n        scan.setFilter(filter01);\n        scan.setFilter(filter);\n\n\n\n        ResultScanner resultScanner = table.getScanner(scan);\n        Iterator<Result> results = resultScanner.iterator();\n\n        while (results.hasNext()) {\n\n            Result result = results.next();\n            //因为我们这里想要获取所有列族的数据，所以不能像上面那样指定具体的某一列族了\n            NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n            for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n                byte[] familyKey = entry.getKey();\n                NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n                for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                    byte[] columnKey = entry1.getKey();\n                    NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                    //对于一个具体的列，可能还有不同的版本\n                    for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                        Long versionKey = entry2.getKey();\n                        byte[] versionValue = entry2.getValue();\n                        System.out.println(\"列族：\"+ new String(familyKey) + \", 列：\" + new String(columnKey) + \",版本号：\" + versionKey + \",值是：\" + new String(versionValue));\n                    }\n                }\n            }\n        }\n\n        resultScanner.close();\n\n\n    }\n\n\n\n\n    //对scan设置rowFilter过滤器\n    @Test\n    public void hbase_rowFilter_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t1\");\n        Table table = connection.getTable(tableName);\n\n        //终于明白了这里设置一个scan的作用是什么了，可以设置过滤器呀\n        Scan scan = new Scan();\n        scan.addColumn(\"f1\".getBytes(), \"name\".getBytes());\n\n        //第一种，二进制对比器\n        /*Filter filter = new RowFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"r0001000\".getBytes()));\n        scan.setFilter(filter);*/\n\n        //第二种，正则对比器, 正则大多也不记得， 先放着吧\n        /*Filter filter2 = new RowFilter(CompareOperator.EQUAL, new RegexStringComparator(\"\"));\n        scan.setFilter(filter2);*/\n\n        //第三种，截串对比器\n        Filter filter3 = new RowFilter(CompareOperator.EQUAL, new SubstringComparator(\"r01999\"));\n        scan.setFilter(filter3);\n\n\n\n        ResultScanner resultScanner = table.getScanner(scan);\n        Iterator<Result> results = resultScanner.iterator();\n\n        while (results.hasNext()) {\n\n            Result result = results.next();\n            //因为我们这里想要获取所有列族的数据，所以不能像上面那样指定具体的某一列族了\n            NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n            for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n                byte[] familyKey = entry.getKey();\n                NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n                for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                    byte[] columnKey = entry1.getKey();\n                    NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                    //对于一个具体的列，可能还有不同的版本\n                    for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                        Long versionKey = entry2.getKey();\n                        byte[] versionValue = entry2.getValue();\n                        System.out.println(\"列族：\"+ new String(familyKey) + \", 列：\" + new String(columnKey) + \",版本号：\" + versionKey + \",值是：\" + new String(versionValue));\n                    }\n                }\n            }\n        }\n    }\n}\n\n```"
    }
  ]
}