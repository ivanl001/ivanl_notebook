{
  "title": "07-HBase-0307-Hbaseè¿‡æ»¤å™¨çš„javaçš„api",
  "cells": [
    {
      "type": "markdown",
      "data": "*ç›´æ¥çœ‹ä»£ç ä¸­æ³¨é‡Š*"
    },
    {
      "type": "markdown",
      "data": "```java\npackage im.ivanl001.bigData.Hbase;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.hbase.CompareOperator;\nimport org.apache.hadoop.hbase.HBaseConfiguration;\nimport org.apache.hadoop.hbase.TableName;\nimport org.apache.hadoop.hbase.client.*;\nimport org.apache.hadoop.hbase.filter.*;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.util.*;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-11-12 19:42\n * #description : è¿‡æ»¤å™¨çš„ä½¿ç”¨\n **/\npublic class A05_Filter {\n\n\n    //########------å»ºè®®å…ˆçœ‹ä¸€ä¸‹æœ€ä¸‹é¢é‚£ä¸ªï¼Œ é‚£ä¸ªæ¯”è¾ƒå…¨ä¸€äº›------#############\n\n    //è¿™é‡Œå› ä¸ºä¹‹å‰æƒ³åŒæ—¶è®¾ç½®ä¸¤ä¸ªfilterçš„æ—¶å€™ï¼Œåè€…ä¼šè¦†ç›–å‰è€…ï¼Œæ‰€ä»¥ä¸èƒ½æˆåŠŸï¼Œè¿™é‡Œç”¨FilterListå¯ä»¥å®ç°ï¼Œå¦‚ä¸‹\n    @Test\n    public void hbase_familyFilter00000_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t2\");\n        Table table = connection.getTable(tableName);\n\n        //ç»ˆäºæ˜ç™½äº†è¿™é‡Œè®¾ç½®ä¸€ä¸ªscançš„ä½œç”¨æ˜¯ä»€ä¹ˆäº†ï¼Œå¯ä»¥è®¾ç½®è¿‡æ»¤å™¨å‘€\n        Scan scan = new Scan();\n        //æ³¨æ„ï¼šå¦‚æœæ·»åŠ åˆ—æ—ï¼Œé‚£ä¹ˆåªä¼šæ‰«ææŒ‡å®šåˆ—æ—çš„å†…å®¹ï¼Œå¦‚æœæ²¡æœ‰æ·»åŠ ï¼Œä¼šæ‰«ææ‰€æœ‰åˆ—æ—\n        //scan.addColumn(\"f1\".getBytes(), \"name\".getBytes());\n        //scan.addColumn(\"f2\".getBytes(), \"age\".getBytes());\n\n        //\n        Filter filter = new FamilyFilter(CompareOperator.EQUAL, new BinaryComparator(\"f2\".getBytes()));\n        Filter filter01 = new RowFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"r0001000\".getBytes()));\n        //å¦‚æœè¿ç»­æ·»åŠ è¿‡æ»¤å™¨ï¼Œåè€…ä¼šè¦†ç›–å‰è€…ï¼ï¼ï¼ï¼ï¼ï¼ï¼\n        /*scan.setFilter(filter01);\n        scan.setFilter(filter);*/\n\n\n        List<Filter> filters = new ArrayList<Filter>();\n        filters.add(filter);\n        filters.add(filter01);\n\n\n        //FilterListæ„é€ å™¨éœ€è¦ä¸€ä¸ªFilterçš„list\n        FilterList filterList = new FilterList(filters);\n\n\n        scan.setFilter(filterList);\n\n\n        ResultScanner resultScanner = table.getScanner(scan);\n        Iterator<Result> results = resultScanner.iterator();\n\n        while (results.hasNext()) {\n\n            Result result = results.next();\n            //å› ä¸ºæˆ‘ä»¬è¿™é‡Œæƒ³è¦è·å–æ‰€æœ‰åˆ—æ—çš„æ•°æ®ï¼Œæ‰€ä»¥ä¸èƒ½åƒä¸Šé¢é‚£æ ·æŒ‡å®šå…·ä½“çš„æŸä¸€åˆ—æ—äº†\n            NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n            for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n                byte[] familyKey = entry.getKey();\n                NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n                for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                    byte[] columnKey = entry1.getKey();\n                    NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                    //å¯¹äºä¸€ä¸ªå…·ä½“çš„åˆ—ï¼Œå¯èƒ½è¿˜æœ‰ä¸åŒçš„ç‰ˆæœ¬\n                    for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                        Long versionKey = entry2.getKey();\n                        byte[] versionValue = entry2.getValue();\n                        System.out.println(\"åˆ—æ—ï¼š\"+ new String(familyKey) + \", åˆ—ï¼š\" + new String(columnKey) + \",ç‰ˆæœ¬å·ï¼š\" + versionKey + \",å€¼æ˜¯ï¼š\" + new String(versionValue));\n                    }\n                }\n            }\n        }\n\n        resultScanner.close();\n\n\n    }\n\n\n\n\n    //è¿™ä¸ªæ˜¯ä¸ªé™æ€æ–¹æ³•ï¼Œæ‡’å¾—é‡å¤æ‹·è´ï¼Œæ‰€ä»¥ç›´æ¥æŠ½å–å‡ºæ¥æ”¾åœ¨è¿™é‡Œæ–¹ä¾¿è°ƒç”¨\n    public static void func(Filter filter) throws Exception {\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t4\");\n        Table table = connection.getTable(tableName);\n\n        //ç»ˆäºæ˜ç™½äº†è¿™é‡Œè®¾ç½®ä¸€ä¸ªscançš„ä½œç”¨æ˜¯ä»€ä¹ˆäº†ï¼Œå¯ä»¥è®¾ç½®è¿‡æ»¤å™¨å‘€\n        Scan scan = new Scan();\n        scan.setFilter(filter);\n\n        ResultScanner resultScanner = table.getScanner(scan);\n        Iterator<Result> results = resultScanner.iterator();\n\n        while (results.hasNext()) {\n\n            Result result = results.next();\n            //å› ä¸ºæˆ‘ä»¬è¿™é‡Œæƒ³è¦è·å–æ‰€æœ‰åˆ—æ—çš„æ•°æ®ï¼Œæ‰€ä»¥ä¸èƒ½åƒä¸Šé¢é‚£æ ·æŒ‡å®šå…·ä½“çš„æŸä¸€åˆ—æ—äº†\n            NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n            for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n                byte[] familyKey = entry.getKey();\n                NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n                for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                    byte[] columnKey = entry1.getKey();\n                    NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                    //å¯¹äºä¸€ä¸ªå…·ä½“çš„åˆ—ï¼Œå¯èƒ½è¿˜æœ‰ä¸åŒçš„ç‰ˆæœ¬\n                    for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                        Long versionKey = entry2.getKey();\n                        byte[] versionValue = entry2.getValue();\n                        System.out.println(\"åˆ—æ—ï¼š\"+ new String(familyKey) + \", åˆ—ï¼š\" + new String(columnKey) + \",ç‰ˆæœ¬å·ï¼š\" + versionKey + \",å€¼æ˜¯ï¼š\" + new String(versionValue));\n                    }\n                }\n            }\n        }\n        resultScanner.close();\n    }\n\n\n\n    //å®ç°likeç±»ä¼¼çš„åŠŸèƒ½\n    @Test\n    public void hbase_like_similar_test() throws Exception {\n\n        //è¿™ä¸ªå¯ä»¥r002%è¿™æ ·çš„æ•ˆæœ\n        Filter filter = new ValueFilter(CompareOperator.EQUAL, new RegexStringComparator(\"^r002\"));\n        func(filter);\n\n    }\n\n\n\n\n\n    //å¤§å¤šç±»ä¼¼ï¼Œå‰©ä¸‹çš„æŒ‘é€‰è¿›è¡Œä»£ç æ¼”ç¤º\n    @Test\n    public void hbase_ColumnCountGetFilter_test() throws Exception {\n        //å–å‰2åˆ—\n        Filter filter = new ColumnCountGetFilter(2);\n        func(filter);\n    }\n\n\n\n\n\n    // åªæœ‰é”®å€¼ï¼Œæ²¡æœ‰å€¼çš„\n    @Test\n    public void hbase_KeyOnlyFilter_test() throws Exception {\n        //åˆ—æ—ï¼šf1, åˆ—ï¼šname,ç‰ˆæœ¬å·ï¼š1542074141465,å€¼æ˜¯ï¼š\n        Filter filter = new KeyOnlyFilter();\n        func(filter);\n\n    }\n\n\n\n    @Test\n    public void hbase_PageFilter_test() throws Exception {\n\n        //å°±å–å‰1æ¡ï¼Œ è¿™ä¸ªæ˜¯æŒ‰åŒºæ¥é™å®šçš„ï¼Œ å¦‚æœæœ‰ä¸‰ä¸ªåŒºï¼Œ å°±æ˜¯æ¯ä¸ªåŒºä¸Šé™å–ä¸¤ä¸ªäº†\n        Filter filter = new PageFilter(2);\n        func(filter);\n        //åœ¨è¿™ä¸ªåŸºç¡€ä¸Šä¹Ÿå¯ä»¥ä½¿ç”¨scançš„startwithrowè¿˜æ˜¯å«ä»€ä¹ˆçš„æ–¹æ³•ï¼Œ æ¥é™å®šå¼€å§‹è¡Œå’Œç»“æŸè¡Œ\n\n    }\n\n\n\n\n\n\n\n    @Test\n    public void hbase_PrefixFilter_test() throws Exception {\n\n        //råšå‰ç¼€çš„ï¼Œ r001, æˆ‘è¿™å¼ è¡¨ä¸­æ·»åŠ äº†ç±»ä¼¼r001ï¼Œ r002ï¼Œ s001ä¹‹ç±»çš„rowkey\n        Filter filter = new PrefixFilter(\"r\".getBytes());//\n        func(filter);\n\n    }\n\n\n\n\n    @Test\n    public void hbase_singleComlumnValueExcludeFilter_test() throws Exception {\n\n        //è¿™é‡Œè®¾å®šå¦‚æœf1åˆ—æ—çš„ageå°äº3ï¼Œé‚£ä¹ˆè¿™ä¸€è¡Œå°±ä¼šè¢«è¿‡æ»¤æ‰, è¯¥è¡Œä½œä¸ºè¿‡æ»¤æ¡ä»¶ï¼Œä¹Ÿæ˜¯ä¸æ˜¾ç¤ºï¼Œä¹Ÿå°±æ˜¯ä¼šè¢«ç›´æ¥è¿‡æ»¤æ‰\n        Filter filter = new SingleColumnValueExcludeFilter(\"f1\".getBytes(), \"age\".getBytes(), CompareOperator.GREATER, \"30\".getBytes());\n        func(filter);\n\n\n    }\n\n\n\n\n\n    //å•è¡Œå€¼è¿‡æ»¤ï¼Œå¦‚æœè¿™ä¸ªå€¼ä¸æ»¡è¶³ï¼Œæ•´è¡Œéƒ½ä¼šè¢«è¿‡æ»¤æ‰ï¼Œæ³¨æ„ï¼šè¿‡æ»¤æ¡ä»¶è¿™ä¸ªåˆ—ä¹Ÿä¼šè¢«è¿‡æ»¤æ‰ï¼Œä¹Ÿå°±æ˜¯ä¸æ˜¾ç¤ºçš„å“ˆ\n    @Test\n    public void habse_singleColumnValueFilter_test() throws Exception {\n\n        //è¿™é‡Œè®¾å®šå¦‚æœf1åˆ—æ—çš„ageå°äº3ï¼Œé‚£ä¹ˆè¿™ä¸€è¡Œå°±ä¼šè¢«è¿‡æ»¤æ‰, ç¬¬äºŒè¡Œå…¨éƒ¨æ˜¾ç¤ºï¼Œ å¯ä»¥å‚è€ƒå¯¹æ¯”ä¸‹ ä¸Šé¢çš„SingleColumnValueExcludeFilter\n        Filter filter = new SingleColumnValueFilter(\"f1\".getBytes(), \"age\".getBytes(), CompareOperator.GREATER, \"30\".getBytes());\n        func(filter);\n    }\n\n\n\n\n    //è¿™ä¸ªå±…ç„¶æ¯è®²å®ŒğŸ˜¢ğŸ˜¢ğŸ˜¢\n    @Test\n    public void hbase_dependentColumnFilter_test() throws Exception {\n\n        //è¿™é‡Œå¥½åƒä¹Ÿä¸å¯¹\n        //ä¸çŸ¥é“è¿™ä¸ªæ˜¯å¹²å˜›ç”¨çš„ï¼Œ æ€ä¹ˆè®¾ç½®éƒ½æ²¡æœ‰ä¸œè¥¿ï¼Œç®—äº†ï¼Œä¼°è®¡ä¹Ÿæ˜¯åºŸçš„\n        Filter filter = new DependentColumnFilter(\"f1\".getBytes(), \"age\".getBytes(), false, CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"10\".getBytes()));\n//        scan.setFilter(filter);\n        func(filter);\n    }\n\n\n\n\n\n\n    //å¯¹getè®¾ç½®qualifierFilterè¿‡æ»¤å™¨\n    @Test\n    public void hbase_valueFileter01_test() throws Exception {\n\n\n        //\n        //Filter filter01 = new RowFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"r0001000\".getBytes()));\n        Filter filter = new ValueFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"ivanl0000100\".getBytes()));\n\n\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t2\");\n        Table table = connection.getTable(tableName);\n\n\n\n        Get get = new Get(\"r0000001\".getBytes());\n        get.setFilter(filter);\n\n\n        Result result = table.get(get);\n\n        //å› ä¸ºæˆ‘ä»¬è¿™é‡Œæƒ³è¦è·å–æ‰€æœ‰åˆ—æ—çš„æ•°æ®ï¼Œæ‰€ä»¥ä¸èƒ½åƒä¸Šé¢é‚£æ ·æŒ‡å®šå…·ä½“çš„æŸä¸€åˆ—æ—äº†\n        NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n        for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n            byte[] familyKey = entry.getKey();\n            NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n            for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                byte[] columnKey = entry1.getKey();\n                NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                //å¯¹äºä¸€ä¸ªå…·ä½“çš„åˆ—ï¼Œå¯èƒ½è¿˜æœ‰ä¸åŒçš„ç‰ˆæœ¬\n                for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                    Long versionKey = entry2.getKey();\n                    byte[] versionValue = entry2.getValue();\n                    System.out.println(\"åˆ—æ—ï¼š\"+ new String(familyKey) + \", åˆ—ï¼š\" + new String(columnKey) + \",ç‰ˆæœ¬å·ï¼š\" + versionKey + \",å€¼æ˜¯ï¼š\" + new String(versionValue));\n                }\n            }\n        }\n    }\n\n\n\n\n\n\n    //å¯¹scanè®¾ç½®valueFileterè¿‡æ»¤å™¨\n    @Test\n    public void hbase_valueFileter_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t2\");\n        Table table = connection.getTable(tableName);\n\n        //ç»ˆäºæ˜ç™½äº†è¿™é‡Œè®¾ç½®ä¸€ä¸ªscançš„ä½œç”¨æ˜¯ä»€ä¹ˆäº†ï¼Œå¯ä»¥è®¾ç½®è¿‡æ»¤å™¨å‘€\n        Scan scan = new Scan();\n\n        //\n        Filter filter = new ValueFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"ivanl0000010\".getBytes()));\n        scan.setFilter(filter);\n\n\n        ResultScanner resultScanner = table.getScanner(scan);\n        Iterator<Result> results = resultScanner.iterator();\n\n        while (results.hasNext()) {\n\n            Result result = results.next();\n            //å› ä¸ºæˆ‘ä»¬è¿™é‡Œæƒ³è¦è·å–æ‰€æœ‰åˆ—æ—çš„æ•°æ®ï¼Œæ‰€ä»¥ä¸èƒ½åƒä¸Šé¢é‚£æ ·æŒ‡å®šå…·ä½“çš„æŸä¸€åˆ—æ—äº†\n            NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n            for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n                byte[] familyKey = entry.getKey();\n                NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n                for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                    byte[] columnKey = entry1.getKey();\n                    NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                    //å¯¹äºä¸€ä¸ªå…·ä½“çš„åˆ—ï¼Œå¯èƒ½è¿˜æœ‰ä¸åŒçš„ç‰ˆæœ¬\n                    for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                        Long versionKey = entry2.getKey();\n                        byte[] versionValue = entry2.getValue();\n                        System.out.println(\"åˆ—æ—ï¼š\"+ new String(familyKey) + \", åˆ—ï¼š\" + new String(columnKey) + \",ç‰ˆæœ¬å·ï¼š\" + versionKey + \",å€¼æ˜¯ï¼š\" + new String(versionValue));\n                    }\n                }\n            }\n        }\n\n        resultScanner.close();\n    }\n\n\n\n\n\n\n    //å¯¹getè®¾ç½®qualifierFilterè¿‡æ»¤å™¨\n    @Test\n    public void hbase_qualifierFilter01_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t2\");\n        Table table = connection.getTable(tableName);\n\n        //\n        //Filter filter01 = new RowFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"r0001000\".getBytes()));\n        Filter filter = new QualifierFilter(CompareOperator.EQUAL, new BinaryComparator(\"age\".getBytes()));\n\n\n        Get get = new Get(\"r0000001\".getBytes());\n        get.setFilter(filter);\n\n\n        Result result = table.get(get);\n\n        //å› ä¸ºæˆ‘ä»¬è¿™é‡Œæƒ³è¦è·å–æ‰€æœ‰åˆ—æ—çš„æ•°æ®ï¼Œæ‰€ä»¥ä¸èƒ½åƒä¸Šé¢é‚£æ ·æŒ‡å®šå…·ä½“çš„æŸä¸€åˆ—æ—äº†\n        NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n        for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n            byte[] familyKey = entry.getKey();\n            NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n            for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                byte[] columnKey = entry1.getKey();\n                NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                //å¯¹äºä¸€ä¸ªå…·ä½“çš„åˆ—ï¼Œå¯èƒ½è¿˜æœ‰ä¸åŒçš„ç‰ˆæœ¬\n                for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                    Long versionKey = entry2.getKey();\n                    byte[] versionValue = entry2.getValue();\n                    System.out.println(\"åˆ—æ—ï¼š\"+ new String(familyKey) + \", åˆ—ï¼š\" + new String(columnKey) + \",ç‰ˆæœ¬å·ï¼š\" + versionKey + \",å€¼æ˜¯ï¼š\" + new String(versionValue));\n                }\n            }\n        }\n    }\n\n\n\n\n\n\n\n\n    //å¯¹scanè®¾ç½®qualifierFilterè¿‡æ»¤å™¨\n    @Test\n    public void hbase_qualifierFilter_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t2\");\n        Table table = connection.getTable(tableName);\n\n        //ç»ˆäºæ˜ç™½äº†è¿™é‡Œè®¾ç½®ä¸€ä¸ªscançš„ä½œç”¨æ˜¯ä»€ä¹ˆäº†ï¼Œå¯ä»¥è®¾ç½®è¿‡æ»¤å™¨å‘€\n        Scan scan = new Scan();\n        //æ³¨æ„ï¼šå¦‚æœæ·»åŠ åˆ—æ—ï¼Œé‚£ä¹ˆåªä¼šæ‰«ææŒ‡å®šåˆ—æ—çš„å†…å®¹ï¼Œå¦‚æœæ²¡æœ‰æ·»åŠ ï¼Œä¼šæ‰«ææ‰€æœ‰åˆ—æ—\n        //scan.addColumn(\"f1\".getBytes(), \"name\".getBytes());\n        //scan.addColumn(\"f2\".getBytes(), \"age\".getBytes());\n\n        //\n        //Filter filter01 = new RowFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"r0001000\".getBytes()));\n        Filter filter = new QualifierFilter(CompareOperator.EQUAL, new BinaryComparator(\"age\".getBytes()));\n\n        //å¦‚æœè¿ç»­æ·»åŠ è¿‡æ»¤å™¨ï¼Œåè€…ä¼šè¦†ç›–å‰è€…ï¼ï¼ï¼ï¼ï¼ï¼ï¼\n        //scan.setFilter(filter01);\n        scan.setFilter(filter);\n\n\n        ResultScanner resultScanner = table.getScanner(scan);\n        Iterator<Result> results = resultScanner.iterator();\n\n        while (results.hasNext()) {\n\n            Result result = results.next();\n            //å› ä¸ºæˆ‘ä»¬è¿™é‡Œæƒ³è¦è·å–æ‰€æœ‰åˆ—æ—çš„æ•°æ®ï¼Œæ‰€ä»¥ä¸èƒ½åƒä¸Šé¢é‚£æ ·æŒ‡å®šå…·ä½“çš„æŸä¸€åˆ—æ—äº†\n            NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n            for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n                byte[] familyKey = entry.getKey();\n                NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n                for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                    byte[] columnKey = entry1.getKey();\n                    NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                    //å¯¹äºä¸€ä¸ªå…·ä½“çš„åˆ—ï¼Œå¯èƒ½è¿˜æœ‰ä¸åŒçš„ç‰ˆæœ¬\n                    for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                        Long versionKey = entry2.getKey();\n                        byte[] versionValue = entry2.getValue();\n                        System.out.println(\"åˆ—æ—ï¼š\"+ new String(familyKey) + \", åˆ—ï¼š\" + new String(columnKey) + \",ç‰ˆæœ¬å·ï¼š\" + versionKey + \",å€¼æ˜¯ï¼š\" + new String(versionValue));\n                    }\n                }\n            }\n        }\n\n        resultScanner.close();\n    }\n\n\n\n\n\n    //å¯¹scanè®¾ç½®familyFilterè¿‡æ»¤å™¨\n    @Test\n    public void hbase_familyFilter01_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t2\");\n        Table table = connection.getTable(tableName);\n\n        Get get = new Get(\"r0000001\".getBytes());\n\n\n        Filter filter = new FamilyFilter(CompareOperator.EQUAL, new BinaryComparator(\"f2\".getBytes()));\n        //Filter filter01 = new RowFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"r0001000\".getBytes()));\n        //è¿™ä¸ªå°±æ˜¯åœ¨getä¸Šæ·»åŠ è¿‡æ»¤å™¨\n        get.setFilter(filter);\n\n\n        Result result = table.get(get);\n        //å› ä¸ºæˆ‘ä»¬è¿™é‡Œæƒ³è¦è·å–æ‰€æœ‰åˆ—æ—çš„æ•°æ®ï¼Œæ‰€ä»¥ä¸èƒ½åƒä¸Šé¢é‚£æ ·æŒ‡å®šå…·ä½“çš„æŸä¸€åˆ—æ—äº†\n        NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n        for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n            byte[] familyKey = entry.getKey();\n            NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n            for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                byte[] columnKey = entry1.getKey();\n                NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                //å¯¹äºä¸€ä¸ªå…·ä½“çš„åˆ—ï¼Œå¯èƒ½è¿˜æœ‰ä¸åŒçš„ç‰ˆæœ¬\n                for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                    Long versionKey = entry2.getKey();\n                    byte[] versionValue = entry2.getValue();\n                    System.out.println(\"åˆ—æ—ï¼š\"+ new String(familyKey) + \", åˆ—ï¼š\" + new String(columnKey) + \",ç‰ˆæœ¬å·ï¼š\" + versionKey + \",å€¼æ˜¯ï¼š\" + new String(versionValue));\n                }\n            }\n        }\n\n\n\n\n    }\n\n\n\n\n\n    //å¯¹scanè®¾ç½®familyFilterè¿‡æ»¤å™¨\n    @Test\n    public void hbase_familyFilter_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t2\");\n        Table table = connection.getTable(tableName);\n\n        //ç»ˆäºæ˜ç™½äº†è¿™é‡Œè®¾ç½®ä¸€ä¸ªscançš„ä½œç”¨æ˜¯ä»€ä¹ˆäº†ï¼Œå¯ä»¥è®¾ç½®è¿‡æ»¤å™¨å‘€\n        Scan scan = new Scan();\n        //æ³¨æ„ï¼šå¦‚æœæ·»åŠ åˆ—æ—ï¼Œé‚£ä¹ˆåªä¼šæ‰«ææŒ‡å®šåˆ—æ—çš„å†…å®¹ï¼Œå¦‚æœæ²¡æœ‰æ·»åŠ ï¼Œä¼šæ‰«ææ‰€æœ‰åˆ—æ—\n        //scan.addColumn(\"f1\".getBytes(), \"name\".getBytes());\n        //scan.addColumn(\"f2\".getBytes(), \"age\".getBytes());\n\n        //\n        Filter filter = new FamilyFilter(CompareOperator.EQUAL, new BinaryComparator(\"f2\".getBytes()));\n        Filter filter01 = new RowFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"r0001000\".getBytes()));\n        //å¦‚æœè¿ç»­æ·»åŠ è¿‡æ»¤å™¨ï¼Œåè€…ä¼šè¦†ç›–å‰è€…ï¼ï¼ï¼ï¼ï¼ï¼ï¼\n        scan.setFilter(filter01);\n        scan.setFilter(filter);\n\n\n\n        ResultScanner resultScanner = table.getScanner(scan);\n        Iterator<Result> results = resultScanner.iterator();\n\n        while (results.hasNext()) {\n\n            Result result = results.next();\n            //å› ä¸ºæˆ‘ä»¬è¿™é‡Œæƒ³è¦è·å–æ‰€æœ‰åˆ—æ—çš„æ•°æ®ï¼Œæ‰€ä»¥ä¸èƒ½åƒä¸Šé¢é‚£æ ·æŒ‡å®šå…·ä½“çš„æŸä¸€åˆ—æ—äº†\n            NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n            for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n                byte[] familyKey = entry.getKey();\n                NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n                for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                    byte[] columnKey = entry1.getKey();\n                    NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                    //å¯¹äºä¸€ä¸ªå…·ä½“çš„åˆ—ï¼Œå¯èƒ½è¿˜æœ‰ä¸åŒçš„ç‰ˆæœ¬\n                    for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                        Long versionKey = entry2.getKey();\n                        byte[] versionValue = entry2.getValue();\n                        System.out.println(\"åˆ—æ—ï¼š\"+ new String(familyKey) + \", åˆ—ï¼š\" + new String(columnKey) + \",ç‰ˆæœ¬å·ï¼š\" + versionKey + \",å€¼æ˜¯ï¼š\" + new String(versionValue));\n                    }\n                }\n            }\n        }\n\n        resultScanner.close();\n\n\n    }\n\n\n\n\n    //å¯¹scanè®¾ç½®rowFilterè¿‡æ»¤å™¨\n    @Test\n    public void hbase_rowFilter_test() throws Exception {\n\n        Configuration configuration = HBaseConfiguration.create();\n        Connection connection = ConnectionFactory.createConnection(configuration);\n\n        TableName tableName = TableName.valueOf(\"ns1:t1\");\n        Table table = connection.getTable(tableName);\n\n        //ç»ˆäºæ˜ç™½äº†è¿™é‡Œè®¾ç½®ä¸€ä¸ªscançš„ä½œç”¨æ˜¯ä»€ä¹ˆäº†ï¼Œå¯ä»¥è®¾ç½®è¿‡æ»¤å™¨å‘€\n        Scan scan = new Scan();\n        scan.addColumn(\"f1\".getBytes(), \"name\".getBytes());\n\n        //ç¬¬ä¸€ç§ï¼ŒäºŒè¿›åˆ¶å¯¹æ¯”å™¨\n        /*Filter filter = new RowFilter(CompareOperator.LESS_OR_EQUAL, new BinaryComparator(\"r0001000\".getBytes()));\n        scan.setFilter(filter);*/\n\n        //ç¬¬äºŒç§ï¼Œæ­£åˆ™å¯¹æ¯”å™¨, æ­£åˆ™å¤§å¤šä¹Ÿä¸è®°å¾—ï¼Œ å…ˆæ”¾ç€å§\n        /*Filter filter2 = new RowFilter(CompareOperator.EQUAL, new RegexStringComparator(\"\"));\n        scan.setFilter(filter2);*/\n\n        //ç¬¬ä¸‰ç§ï¼Œæˆªä¸²å¯¹æ¯”å™¨\n        Filter filter3 = new RowFilter(CompareOperator.EQUAL, new SubstringComparator(\"r01999\"));\n        scan.setFilter(filter3);\n\n\n\n        ResultScanner resultScanner = table.getScanner(scan);\n        Iterator<Result> results = resultScanner.iterator();\n\n        while (results.hasNext()) {\n\n            Result result = results.next();\n            //å› ä¸ºæˆ‘ä»¬è¿™é‡Œæƒ³è¦è·å–æ‰€æœ‰åˆ—æ—çš„æ•°æ®ï¼Œæ‰€ä»¥ä¸èƒ½åƒä¸Šé¢é‚£æ ·æŒ‡å®šå…·ä½“çš„æŸä¸€åˆ—æ—äº†\n            NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> tMap = result.getMap();\n\n            for (Map.Entry<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> entry : tMap.entrySet()) {\n\n                byte[] familyKey = entry.getKey();\n                NavigableMap<byte[], NavigableMap<Long, byte[]>> familyValue = entry.getValue();\n\n                for (Map.Entry<byte[], NavigableMap<Long, byte[]>> entry1 : familyValue.entrySet()) {\n                    byte[] columnKey = entry1.getKey();\n                    NavigableMap<Long, byte[]> columnValue = entry1.getValue();\n                    //å¯¹äºä¸€ä¸ªå…·ä½“çš„åˆ—ï¼Œå¯èƒ½è¿˜æœ‰ä¸åŒçš„ç‰ˆæœ¬\n                    for (Map.Entry<Long, byte[]> entry2 : columnValue.entrySet()) {\n                        Long versionKey = entry2.getKey();\n                        byte[] versionValue = entry2.getValue();\n                        System.out.println(\"åˆ—æ—ï¼š\"+ new String(familyKey) + \", åˆ—ï¼š\" + new String(columnKey) + \",ç‰ˆæœ¬å·ï¼š\" + versionKey + \",å€¼æ˜¯ï¼š\" + new String(versionValue));\n                    }\n                }\n            }\n        }\n    }\n}\n\n```"
    }
  ]
}