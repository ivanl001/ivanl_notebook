{
  "title": "01-Java基础-0101-计算机基础",
  "cells": [
    {
      "type": "markdown",
      "data": "## 1, 计算机相关基础"
    },
    {
      "type": "markdown",
      "data": "\n### 1.1, bit, byte, kb(kilobyte), MB(mega byte), Gigabyte\n> bit是计算机存储的最小单位， 也就是一个二进制位\n1 byte = 8 bit, 也就是一个字节等于8位，也就是2的8次方，也就是256，也就是说一个字节表示的是0-255个值\n\n> 1 G = 1024 M = 1024 * 1024 KB = 1024 * 1024 * 1024 byte = 1024 * 1024 * 1024 * 8 bit\n\n> 数据存储是以“字节”（Byte）为单位, 数据传输大多是以“位”（bit，又名“比特”）为单位\n\n> 字符是指我们习惯的一个记录单位，比如说一个英文字符，一个数字字符，一个中文字符，一个日本字符等等， 字符在计算机中存的位数是根据编码方式和不同的字符类型的不同有所不同的，比如说ANSI中的字符采用8bit，一共可以表示255个不同的“字”，也即是一个字节，而UNICODE中的字符采用16bit，也就是两个字节，一共可以表示65535个不同的”字“，很明显前者是没办法把世界所有语言的”字“容纳进去的，比如说仅仅中国的汉字就不止255个，所以如果想要表示英文外的大多数语言，都必须要用到UNICODE编码\n\n*以下是网络上的一些解释：详细解释可见：https://blog.csdn.net/guanfengliang1988/article/details/50440197*\n\n```\n字符是各种文字和符号的总称，包括各个国家文字、标点符号、图形符号、数字等。字符集是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集有：ASCII字符集、ISO 8859字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。 \n \n编码(encoding)和字符集不同。字符集只是字符的集合，不一定适合作网络传送、处理，有时须经编码(encode)后才能应用。如Unicode可依不同需要以UTF-8、UTF-16、UTF-32等方式编码。\n \n字符编码就是以二进制的数字来对应字符集的字符。\n \n因此，对字符进行编码，是信息交流的技术基础。\n \n使用哪些字符。也就是说哪些汉字，字母和符号会被收入标准中。所包含“字符”的集合就叫做“字符集”。\n规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“编码”。\n \n各个国家和地区在制定编码标准的时候，“字符的集合”和“编码”一般都是同时制定的。因此，平常我们所说的“字符集”，比如：GB2312, GBK, JIS 等，除了有“字符的集合”这层含义外，同时也包含了“编码”的含义。\n \n注意：Unicode字符集有多种编码方式，如UTF-8、UTF-16等；ASCII只有一种；大多数MBCS（包括GB2312）也只有一种。\n\n\n\nASCII第一次以规范标准的型态发表是在1967年，最后一次更新则是在1986年，至今为止共定义了128个字符；其中33个字符无法显示（这是以现今操作系统为依归，但在DOS模式下可显示出一些诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符。控制字符的用途主要是用来操控已经处理过的文字。在33个字符之外的是95个可显示的字符，包含用键盘敲下空白键所产生的空白字符也算1个可显示字符（显示为空白）。\nASCII表：见http://zh.wikipedia.org/zh-cn/ASCII\n \nASCII缺点：\nASCII的最大缺点是只能显示26个基本拉丁字母、阿拉伯数目字和英式标点符号，因此只能用于显示现代美国英语（而且在处理英语当中的外来词如naïve、café、élite等等时，所有重音符号都不得不去掉，即使这样做会违反拼写规则）。而EASCII虽然解决了部份西欧语言的显示问题，但对更多其他语言依然无能为力。因此现在的苹果电脑已经抛弃ASCII而转用Unicode。\n \n最早的英文DOS操作系统的系统内码是：ASCII。计算机这时候只支持英语，其他语言不能够在计算机存储和显示。\n\n```\n\n"
    },
    {
      "type": "markdown",
      "data": "### 1.2, 位运算相关\n\n> im.ivanl001.bigData.java_01.A01_BitOperationTest\n\n> & 与运算，对齐位数，相同为一，不同为零， 所以0和任何的数与运算结果都为零\n\n> | 或运算， 对齐位数，有一个是一就是一，否则为零\n\n> ~ 按位取反，所有二进制的零变成一，一变成零\n 所以-1的取反就是0， 0的取反就是1\n \n> ^ 异或运算, 相同为零，不同为一，所以零和-1的异或运算结果是-1，因为所有位都不一样\n\n```\n10    0000 1010  => 10\n5     0000 0101  => 5\n&:    0000 0000  => 0\n|:    0000 1111  => 15\n\n\n```\n\n#### 1.2.1, 正负数的三码(可以理解成计算机中记录的数字都是补码，只不过正数补码和原码一样，不过负数是不同的)\n * 计算机中整数的原码，反码，补码都相同。\n * 负数的原码就是该十进制数的二进制写法，只不过首位的数字代表符号，0代表整数，1代表负数\n   * 负数的反码是原码所有的0变为1,1变为0（解释以下这样做目的：运算中负数加正数其实就是两个正数的减法，但是减法在计算机中并不好表示，所以变成反码后就可以把负数加上正数这种类减法变成加法，只不过这样还是有一个小问题就是原码变反码就不是完全的减法变加法，中间还差了1，所以负数在计算机中存储的实际上是补码，看下面）\n   * 负数的补码是负数的反码加一，加上一之后，负数(这里指补码)和正数的运算就和十进制的运算是等价的了\n   "
    },
    {
      "type": "markdown",
      "data": "### 1.3，把int类型转成一个字节数组(因为int占据4个字节，所以字节数组长度为4即可)\n```java\nbyte[] bytes = new byte[4];\n//假设这个值是1,也就是00000000 0000000 00000000 00000001\nint i = 128;\nbytes[0] = (byte)i;//取最后四位//11111111\nbytes[1] = (byte) (i >> 8);  //00000000\nbytes[2] = (byte) (i >> 16); //00000000\nbytes[3] = (byte) (i >> 24); //00000000\nSystem.out.println(\"bytes[0]:\"+bytes[0]);//因为是字节，而且所有位数都是1，那么这个字节直接打印出来就是-1\nSystem.out.println(\"bytes[1]:\"+bytes[1]);\nSystem.out.println(\"bytes[2]:\"+bytes[2]);\nSystem.out.println(\"bytes[3]:\"+bytes[3]);\n\n\n//------------------再转换回去的时候就会有问题，因为涉及到不足到位数是补0还是补1的问题-------------------\n//下面如何不&0xFF的话，127及小于127的数字，也即是小于2^7的数都ok，大于这个数就歇菜了\n//如果是正数，类型转换位数增加的时候，前面是补0的，但是如果是负数，前面是补1，所以如果这个数小于128，也就是前7位填满，第8位表示符号，为0，如果第八位是1，那么这就是个负数，那么前面补1，就会有问题 所以这个时候用&符号的时候，可以纠正这个问题，&0xFF之后，其他位都是0，那么再进行移位就完全没有问题了\nint int_0 = (bytes[0] & 0xFF);\nint int_1 = (bytes[1] & 0xFF) << 8;\nint int_2 = (bytes[2] & 0xFF) << 16;\nint int_3 = (bytes[3] & 0xFF) << 24;\nSystem.out.println(\"int_0   :\" + int_0);\nSystem.out.println(\"int_1   :\" + int_1);\nSystem.out.println(\"int_2   :\" + int_2);\nSystem.out.println(\"int_3   :\" + int_3);\n\nint resultInt = int_0 | int_1 | int_2 | int_3;\nSystem.out.println(resultInt);\n```"
    },
    {
      "type": "markdown",
      "data": "### 1.4，几个特殊的原码，反码和补码， 这里只讨论int类型\n\n> 取反+1 : 符号位是不参与取反的\n\n> int中最大值是0x7fffffff，也就是2^31-1=2147483647\n\n\n> int中最大值+1，也就是0x7fffffff + 1的话，因为会越位，直接导致进到最大位上，最后结果是-2147483648\n\n* 原因分析：0x7fffffff+1的直接后果是：1000 0000 0000 0000 0000 0000 0000 0000, 其实这个值应该是-0，但是计算机中已经有0000 0000 0000 0000 0000 0000 0000 0000表示0，再加一个-0是很明显的浪费行为，所以被这个值定为-2147483648\n\n* 这样也就是计算机中数字闭合成一个圆，最大值+1为最小值，再接着加就可以重新回到0，回到最大值，这个是我自己瞎猜的，可能不是愿意图，哈哈\n* 最大正值：0xfffffff\n    * 原码：0111 1111 1111 1111 1111 1111 1111 1111\n    * 反码：0111 1111 1111 1111 1111 1111 1111 1111\n    * 补码：0111 1111 1111 1111 1111 1111 1111 1111\n    * +1  ：1000 0000 0000 0000 0000 0000 0000 0000 //和下面的补码是一样的，其实也就是-0\n    \n* -2147483648:\n    * 原码：1000 0000 0000 0000 0000 0000 0000 0000\n    * 反码：1111 1111 1111 1111 1111 1111 1111 1111\n    * 补码：1000 0000 0000 0000 0000 0000 0000 0000 //反码加1其实是进上去了，所以反推的时候好像推不回来\n\n* 0 ：\n    * 原码：0000 0000 0000 0000 0000 0000 0000 0000\n    * 反码：0111 1111 1111 1111 1111 1111 1111 1111\n    * 补码：1000 0000 0000 0000 0000 0000 0000 0000\n    \n* -1 ：\n    * 原码：1000 0000 0000 0000 0000 0000 0000 0001\n    * 反码：1111 1111 1111 1111 1111 1111 1111 1110\n    * 补码：1111 1111 1111 1111 1111 1111 1111 1111\n\n* 顺便看下两个int最大值相加是多少：\n* 最大：0111 1111 1111 1111 1111 1111 1111 1111\n* 最大：0111 1111 1111 1111 1111 1111 1111 1111\n* 相加：1111 1111 1111 1111 1111 1111 1111 1110\n* 相加之后是上面的那个值，那么看看原码是多少\n* -1  ：1111 1111 1111 1111 1111 1111 1111 1101\n* 取反：1000 0000 0000 0000 0000 0000 0000 0010\n* 看到没，是-2\n    "
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    }
  ]
}