{
  "title": "01-时间复杂度和空间复杂度：十分钟搞定时间复杂度",
  "cells": [
    {
      "type": "markdown",
      "data": "*拷贝：https://www.jianshu.com/p/f4cca5ce055a，仅供学习*\n* 最后两个练习没有明白，后面有时间再说哈"
    },
    {
      "type": "markdown",
      "data": "* 我们假设计算机运行一行基础代码需要执行一次运算。\n\n  ```c\n  int aFunc(void) {\n      printf(\"Hello, World!\\n\");      //  需要执行 1 次\n      return 0;       // 需要执行 1 次\n  }\n  ```\n\n* 那么上面这个方法需要执行 2 次运算\n  ```c\n  int aFunc(int n) {\n      for(int i = 0; i<n; i++) {         // 需要执行 (n + 1) 次\n          printf(\"Hello, World!\\n\");      // 需要执行 n 次\n      }\n      return 0;       // 需要执行 1 次\n  }\n  ```\n\n* 这个方法需要 (n + 1 + n + 1) = 2n + 2 次运算。\n\n* 我们把 算法需要执行的运算次数 用 输入大小n 的函数 表示，即 T(n) 。\n此时为了 估算算法需要的运行时间 和 简化算法分析，我们引入时间复杂度的概念\n\n* 定义：存在常数 c 和函数 f(N)，使得当 N >= c 时 T(N) <= f(N)，表示为 T(n) = O(f(n)) 。\n如图：\n\n  ![IMAGE](quiver-image-url/D25B32336ADD95F67EF9AADA5C45AAED.jpg =677x417)\n\n* 当 N >= 2 的时候，f(n) = n^2 总是大于 T(n) = n + 2 的，于是我们说 f(n) 的增长速度是大于或者等于 T(n) 的，也说 f(n) 是 T(n) 的上界，可以表示为 T(n) = O(f(n))。\n\n* 因为f(n) 的增长速度是大于或者等于 T(n) 的，即T(n) = O(f(n))，所以我们可以用 f(n) 的增长速度来度量 T(n) 的增长速度，所以我们说这个算法的时间复杂度是 O(f(n))。\n\n\n* ### 算法的时间复杂度，用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。\n\n* 显然如果 T(n) = n^2，那么 T(n) = O(n^2)，T(n) = O(n^3)，T(n) = O(n^4) 都是成立的，但是因为第一个 f(n) 的增长速度与 T(n) 是最接近的，所以第一个是最好的选择，所以我们说这个算法的复杂度是 O(n^2) 。\n\n* 那么当我们拿到算法的执行次数函数 T(n) 之后怎么得到算法的时间复杂度呢？\n\n* 1, 我们知道常数项对函数的增长速度影响并不大，所以当 T(n) = c，c为一个常数的时候，我们说这个算法的时间复杂度为 O(1)；如果 T(n)不等于一个常数项时，直接将常数项省略。\n  ```c\n  比如\n  第一个 Hello, World 的例子中 T(n) = 2，所以我们说那个函数(算法)的时间复杂度为 O(1)。\n  T(n) = n + 29，此时时间复杂度为 O(n)。\n  ```\n\n* 2, 我们知道高次项对于函数的增长速度的影响是最大的。n^3 的增长速度是远超 n^2 的，同时 n^2 的增长速度是远超 n 的。 同时因为要求的精度不高，所以我们直接忽略低此项。\n  ```c\n  比如\n  T(n) = n^3 + n^2 + 29，此时时间复杂度为 O(n^3)。\n  ```\n\n* 3, 因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。\n  ```c\n  比如\n  T(n) = 3n^3，此时时间复杂度为 O(n^3)。\n  ```\n  \n* ### 综合起来：如果一个算法的执行次数是T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大O推导法。\n\n\n\n* 由此可见，由执行次数 T(n)得到时间复杂度并不困难，很多时候困难的是从算法通过分析和数学运算得到 T(n)。对此，提供下列四个便利的法则，这些法则都是可以简单推导出来的，总结出来以便提高效率。\n\n* 1, 对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个\n循环的时间复杂度为 O(n×m)。\n\n```c\nvoid aFunc(int n) {\n    for(int i = 0; i < n; i++) {         // 循环次数为 n\n        printf(\"Hello, World!\\n\");      // 循环体时间复杂度为 O(1)\n    }\n}\n```\n* 此时时间复杂度为 O(n × 1)，即 O(n)。\n\n* 2, 对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c...，则这个循环的时间复杂度为 O(n×a×b×c...)。分析的时候应该由里向外分析这些循环。\n\n```c\nvoid aFunc(int n) {\n    for(int i = 0; i < n; i++) {         // 循环次数为 n\n        for(int j = 0; j < n; j++) {       // 循环次数为 n\n            printf(\"Hello, World!\\n\");      // 循环体时间复杂度为 O(1)\n        }\n    }\n}\n```\n* 此时时间复杂度为 O(n × n × 1)，即 O(n^2)。\n\n* 3, 对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。\n\n```c\nvoid aFunc(int n) {\n    // 第一部分时间复杂度为 O(n^2)\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            printf(\"Hello, World!\\n\");\n        }\n    }\n    // 第二部分时间复杂度为 O(n)\n    for(int j = 0; j < n; j++) {\n        printf(\"Hello, World!\\n\");\n    }\n}\n```\n\n* 此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。\n\n\n\n* 4, 对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。\n```c\nvoid aFunc(int n) {\n    if (n >= 0) {\n        // 第一条路径时间复杂度为 O(n^2)\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                printf(\"输入数据大于等于零\\n\");\n            }\n        }\n    } else {\n        // 第二条路径时间复杂度为 O(n)\n        for(int j = 0; j < n; j++) {\n            printf(\"输入数据小于零\\n\");\n        }\n    }\n}\n```\n* 此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。\n\n\n\n最后，我们来练习一下\n\n一. 基础题\n求该方法的时间复杂度\n\n```c\nvoid aFunc(int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            printf(\"Hello World\\n\");\n        }\n    }\n}\n```\n\n参考答案：\n当 i = 0 时，内循环执行 n 次运算，当 i = 1 时，内循环执行 n - 1 次运算……当 i = n - 1 时，内循环执行 1 次运算。\n所以，执行次数 T(n) = n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2。\n根据上文说的 大O推导法 可以知道，此时时间复杂度为 O(n^2)。\n\n二. 进阶题\n求该方法的时间复杂度\n\n```c\nvoid aFunc(int n) {\n    for (int i = 2; i < n; i++) {\n        i *= 2;\n        printf(\"%i\\n\", i);\n    }\n}\n```\n\n参考答案：\n假设循环次数为 t，则循环条件满足 2^t < n。\n可以得出，执行次数t = log(2)(n)，即 T(n) = log(2)(n)，可见时间复杂度为 O(log(2)(n))，即 O(log n)。\n\n三. 再次进阶\n求该方法的时间复杂度\n\n```c\nlong aFunc(int n) {\n    if (n <= 1) {\n        return 1;\n    } else {\n        return aFunc(n - 1) + aFunc(n - 2);\n    }\n}\n```\n参考答案：\n显然运行次数，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。\n显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n >= 1 时 T(n) < (5/3)^n，同时当 n > 4 时 T(n) >= (3/2)^n。\n所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。\n可见这个方法所需的运行时间是以指数的速度增长的。如果大家感兴趣，可以试下分别用 1，10，100 的输入大小来测试下算法的运行时间，相信大家会感受到时间复杂度的无穷魅力。\n"
    },
    {
      "type": "markdown",
      "data": ""
    }
  ]
}