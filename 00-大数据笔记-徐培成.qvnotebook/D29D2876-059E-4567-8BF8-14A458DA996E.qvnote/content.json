{
  "title": "03-Hadoop-0609-MapFile",
  "cells": [
    {
      "type": "markdown",
      "data": "\n```java\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.IntWritable;\nimport org.apache.hadoop.io.MapFile;\nimport org.apache.hadoop.io.Text;\nimport org.junit.Test;\n\nimport java.net.URI;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-10-24 12:31\n * #description : key想要按序写入，key和value是分别放在两个不同的seqFile里面的\n * MapFile的好处是key是有序的，那么就可以建立索引，这个时候查找的速度就会很快\n **/\npublic class A04_MapFile {\n\n\n    //----------------------------对比------------------------------\n    /*\n     * 对比了一下seqfile和mapfile，发现对于查找相同的数据：\n     * seqfile的seek是查找的同步点，那个点不好定位具体的某个key，\n     * mapfile的seek可以直接seek到某个key\n     * 但是对于找到最后的比如说1000条数据并打印出来的时间，两者并没有特别的差距，不知道是不是不能这样比较，毕竟seek的方式本身就不一样\n     *\n     */\n\n\n    @Test\n    public void mapFileRead() throws Exception{\n\n        //这里只需要给定文件夹即可，在读取的时候reader会自动的定位到文件夹中的data文件的\n        String pathStr = \"/Users/ivanl001/Desktop/bigData/mapfile\";\n        Configuration configuration = new Configuration();\n        FileSystem fileSystem = FileSystem.get(configuration);\n\n        Path path = new Path(pathStr);\n        MapFile.Reader reader = null;\n\n        reader = new MapFile.Reader(fileSystem, pathStr, configuration);\n        IntWritable key = new IntWritable();\n        Text value = new Text();\n\n        long time01 = System.currentTimeMillis();\n\n        //这里可以快速的定位到想要的位置,seek的位置就是key，而不是和seqfile中的那样，seek出来的是一个对应的索引值\n        reader.seek(new IntWritable(996996));\n\n        //第一种方式\n        while (reader.next(key, value)) {\n            System.out.println(key.get() + \":\" + value.toString());\n            System.out.println(\"-------------\");\n        }\n\n        long time02 = System.currentTimeMillis();\n        System.out.println(\"time:\" + (time02 - time01));\n        //第二种方式\n        /*while (reader.next(key)) {\n            reader.getCurrentValue(value);\n            System.out.println(\"position: \" + reader.getPosition() + \", \" + key.get() + \":\" + value.toString());\n        }*/\n    }\n\n\n    @Test\n    public void mapFileWrite() throws Exception{\n\n        //这里只需要给定一个文件夹即可，因为mapfile保存的时候并不是只保存一个文件，而是key和value分别保存在不同的文件里面的\n        String uri = \"/Users/ivanl001/Desktop/bigData/mapfile/\";\n        Configuration conf = new Configuration();\n        FileSystem fs = FileSystem.get(URI.create(uri), conf);\n        Path path = new Path(uri);\n        IntWritable key = new IntWritable();\n        Text value = new Text();\n\n        MapFile.Writer writer = new MapFile.Writer(conf, fs, uri, key.getClass(), value.getClass());\n\n        for(int i=0;i<1000000;i++){\n            writer.append(new IntWritable(i), new Text(\"ivanl00\"+i));\n        }\n\n        //如果有下面的几行的话，会报错：\n        /*\n         java.io.IOException: key out of order: 0 after 99\n         意思就是：序号没有按照大小顺序排列\n         */\n        /*for (int i = 0; i < 10; i++) {\n            writer.append(new IntWritable(i), new Text(\"ivanl00\"+i));\n        }*/\n\n        writer.close();\n    }\n}\n\n\n```"
    }
  ]
}