{
  "title": "10-Storm-0209-Storm消费确认机制",
  "cells": [
    {
      "type": "markdown",
      "data": "> collector.ack(tuple);//成功回调\n> collector.fail(tuple);//失败回调\n### 下面用spout和bolt之间的消息确认机制来演示一下"
    },
    {
      "type": "markdown",
      "data": "#### WordCountApp,这个里面其实并没有任何消息确认机制的代码\n```java\npackage im.ivanl001.bigData.Storm.A05_Message_fail;\n\nimport org.apache.storm.Config;\nimport org.apache.storm.StormSubmitter;\nimport org.apache.storm.generated.AlreadyAliveException;\nimport org.apache.storm.generated.AuthorizationException;\nimport org.apache.storm.generated.InvalidTopologyException;\nimport org.apache.storm.topology.TopologyBuilder;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-11-17 09:09\n * #description : 单词统计app,这里学习一下消息验证机制\n **/\npublic class WordCountApp {\n\n\n    public static void main(String[] args) throws InterruptedException, InvalidTopologyException, AuthorizationException, AlreadyAliveException {\n\n        Config config = new Config();\n        config.setDebug(false);\n        //这个是设置开启几个worker\n        config.setNumWorkers(2);\n\n        TopologyBuilder builder = new TopologyBuilder();\n\n        //parallelism_hint是设置并发的数量，比如下面spout设置成2,那么会开两个线程，跑3个任务，这个时候一个线程就必须同时跑两个任务，这其实不太好，所以并发数需要尽量大于任务数\n        builder.setSpout(\"wordCountSpout\", new WordCountSpout(), 2).setNumTasks(2);\n\n        builder.setBolt(\"wordCountSplitBolt\", new WordCountSplitBolt(), 3).shuffleGrouping(\"wordCountSpout\").setNumTasks(3);\n        //builder.setBolt(\"wordCountSumBolt\", new WordCountSumBolt(), 4).fieldsGrouping(\"wordCountSplitBolt\", new Fields(\"word\")).setNumTasks(4);\n\n\n        //这里用本地模式来测试分区模式，消息还是发送到master上的nc好了，懒得改了，一样看\n        /*LocalCluster localCluster = new LocalCluster();\n        localCluster.submitTopology(\"localWordCountCluster\", config, builder.createTopology());\n        Thread.sleep(10000);\n        localCluster.shutdown();*/\n\n        //集群提交\n        StormSubmitter.submitTopology(\"wordCountCluster\", config, builder.createTopology());\n    }\n}\n```"
    },
    {
      "type": "markdown",
      "data": "#### WordCountSpout，在这里类里面处理成功回调或者失败回调的处理办法\n```java\npackage im.ivanl001.bigData.Storm.A05_Message_fail;\n\nimport im.ivanl001.bigData.IMUtils.IMTrackerUtils;\nimport org.apache.storm.spout.SpoutOutputCollector;\nimport org.apache.storm.task.TopologyContext;\nimport org.apache.storm.topology.IRichSpout;\nimport org.apache.storm.topology.OutputFieldsDeclarer;\nimport org.apache.storm.tuple.Fields;\nimport org.apache.storm.tuple.Values;\n\nimport java.util.*;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-11-17 09:09\n * #description : 单词统计的源\n **/\npublic class WordCountSpout implements IRichSpout {\n\n    //在这里定义一些输入，方便后面的Bolt进行计算\n    //private TopologyContext context;\n    private SpoutOutputCollector collector;\n    private List<String> words;\n    private Random random;\n\n    private int i = 0;\n\n    //消息集合，存放所有的消息，成功的需要及时删除\n    private Map<Long, String> messages = new HashMap<Long, String>();\n    //失败回传消息集合，需要记录重发次数\n    private Map<Long, Integer> failedMsg = new HashMap<Long, Integer>();\n\n\n    public void open(Map map, TopologyContext topologyContext, SpoutOutputCollector spoutOutputCollector) {\n\n        IMTrackerUtils.writeTo(this, \"WordCountSpout----open\", \"master\", 8880);\n\n        //this.context = topologyContext;\n        this.collector = spoutOutputCollector;\n        words = new ArrayList<String>();\n\n        words.add(\"ivanl001 is the king of world!\");\n        words.add(\"ivanl002 is the king of world!\");\n        words.add(\"ivanl003 is the king of world!\");\n        words.add(\"ivanl004 is the king of world!\");\n        words.add(\"ivanl005 is the king of world!\");\n        words.add(\"ivanl006 is the king of world!\");\n\n        random = new Random();\n    }\n\n    public void close() {\n\n    }\n\n    public void activate() {\n\n    }\n\n    public void deactivate() {\n\n    }\n\n    public void nextTuple() {\n\n        //这里限制一下发5条吧\n        i += 1;\n        if (i > 5) {\n            return;\n        }\n\n        System.out.println(\"---------------------------nextTuple----------------------------\");\n\n        String line = words.get(random.nextInt(words.size()));\n\n        //这里是用时间戳作为消息id，后面接收到回调的时候方便根据消息id获取内容\n        Long timestamp = System.currentTimeMillis();\n        //发送之前先存到message中，方便成功回传后删除， 失败回传后获取重新发送\n        messages.put(timestamp, line);\n\n        collector.emit(new Values(line), timestamp);\n\n        IMTrackerUtils.writeTo(this, \"WordCountSpout----nextTuple----\" + line + \"-----\" + timestamp , \"master\", 8880);\n\n        //这里为了防止发送太快，延迟一下, 已经限制数量了，这里无所谓了\n        /*try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }*/\n    }\n\n    public void ack(Object timstamp) {\n        Long theTimestamp = (Long) timstamp;\n\n\n        Integer retrytimes = failedMsg.get(theTimestamp);\n        retrytimes = (retrytimes == null) ? 0 : retrytimes;\n        IMTrackerUtils.writeTo(this, \"WordCountSpout----ack-----\" + theTimestamp + \"----次数---\" + retrytimes, \"master\", 8880);\n\n        failedMsg.remove(theTimestamp);\n        messages.remove(theTimestamp);\n\n    }\n\n    public void fail(Object timstamp) {\n        //如果出错了，先从错误消息中取出来看看是否存在，是否已经重发3次\n        Long theTimestamp = (Long) timstamp;\n        Integer retrytimes = failedMsg.get(theTimestamp);\n        retrytimes = (retrytimes == null) ? 0 : retrytimes;\n        IMTrackerUtils.writeTo(this, \"WordCountSpout----fail-----\" + theTimestamp + \"----次数---\" + retrytimes, \"master\", 8880);\n\n        if (retrytimes >= 3) {\n            failedMsg.remove(theTimestamp);\n        }else {\n             //如果次数小于等于3，需要重新发送\n            collector.emit(new Values(messages.get(theTimestamp)), theTimestamp);\n            retrytimes += 1;\n            failedMsg.put(theTimestamp, retrytimes);\n        }\n\n    }\n\n    public void declareOutputFields(OutputFieldsDeclarer outputFieldsDeclarer) {\n        outputFieldsDeclarer.declare(new Fields(\"line\"));\n    }\n\n    public Map<String, Object> getComponentConfiguration() {\n        return null;\n    }\n}\n```"
    },
    {
      "type": "markdown",
      "data": "#### WordCountSplitBolt, 这里进行成功回调发送或者失败回调发送\n```java\npackage im.ivanl001.bigData.Storm.A05_Message_fail;\n\nimport im.ivanl001.bigData.IMUtils.IMTrackerUtils;\nimport org.apache.storm.task.OutputCollector;\nimport org.apache.storm.task.TopologyContext;\nimport org.apache.storm.topology.IRichBolt;\nimport org.apache.storm.topology.OutputFieldsDeclarer;\nimport org.apache.storm.tuple.Fields;\nimport org.apache.storm.tuple.Tuple;\n\nimport java.util.Map;\nimport java.util.Random;\n\n/**\n * #author      : ivanl001\n * #creator     : 2018-11-17 09:21\n * #description : 分裂语句节点\n **/\npublic class WordCountSplitBolt implements IRichBolt {\n\n    //private TopologyContext context;\n    private OutputCollector collector;\n    private int num = 0;\n\n    public void prepare(Map map, TopologyContext topologyContext, OutputCollector outputCollector) {\n\n        IMTrackerUtils.writeTo(this, \"WordCountSplitBolt----prepare\", \"master\", 8881);\n\n        //this.context = topologyContext;\n        this.collector = outputCollector;\n    }\n\n    //在这里执行计算操作\n    public void execute(Tuple tuple) {\n\n        //这里只让发送五行\n        if (num < 5) {\n\n            //这里可以通过字段名获取，也可以通过索引获取\n            String line = tuple.getString(0);\n\n            IMTrackerUtils.writeTo(this, \"WordCountSplitBolt----execute\" + \":::\" + line, \"master\", 8881);\n\n            if (new Random().nextBoolean()) {\n                //这里是消费成功，进行确认，发送的节点，这里发送的节点也就是spout，会收到回调通知\n                collector.ack(tuple);\n            }else{\n                //随机让失败一些，方便我们处理，如果失败的话， 需要重新发送，并需要设定重新发送的最高次数，不能一直重复一直发送\n                collector.fail(tuple);\n            }\n\n            /*String[] words = line.split(\" \");\n            for (String word : words) {\n                collector.emit(new Values(word, 1));\n            }*/\n            num += 1;\n        }\n    }\n\n    public void cleanup() {\n\n    }\n\n    public void declareOutputFields(OutputFieldsDeclarer outputFieldsDeclarer) {\n        outputFieldsDeclarer.declare(new Fields(\"word\", \"count\"));\n    }\n\n    public Map<String, Object> getComponentConfiguration() {\n        return null;\n    }\n}\n```"
    }
  ]
}